<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
		<title>17-template</title>
		<style>
			/* PDF Specific */

@media print {
  body {
    min-width: initial;
    max-width: 100%;
    margin: 0 auto;
  }
}

/* General */

.octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.anchor:focus {
  outline: none;
}

h1 .octicon-link,
h2 .octicon-link,
h3 .octicon-link,
h4 .octicon-link,
h5 .octicon-link,
h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
  text-decoration: none;
}

h1:hover .anchor .octicon-link,
h2:hover .anchor .octicon-link,
h3:hover .anchor .octicon-link,
h4:hover .anchor .octicon-link,
h5:hover .anchor .octicon-link,
h6:hover .anchor .octicon-link {
  visibility: visible;
}

h1:hover .anchor .octicon-link:before,
h2:hover .anchor .octicon-link:before,
h3:hover .anchor .octicon-link:before,
h4:hover .anchor .octicon-link:before,
h5:hover .anchor .octicon-link:before,
h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' width='16' height='16' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z'%3E%3C/path%3E%3C/svg%3E");
}

body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  -webkit-print-color-adjust: exact;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial,
    sans-serif, Apple Color Emoji, Segoe UI Emoji;
  font-size: 16px;
  line-height: 1.5;
  color: #24292e;
  word-wrap: break-word;
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 1rem auto;
}

details {
  display: block;
}

summary {
  display: list-item;
}

a {
  background-color: initial;
}

a:active,
a:hover {
  outline-width: 0;
}

strong {
  font-weight: inherit;
  font-weight: bolder;
}

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

img {
  border-style: none;
}

code,
kbd,
pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

hr {
  box-sizing: initial;
  height: 0;
  overflow: visible;
}

input {
  font: inherit;
  margin: 0;
}

input {
  overflow: visible;
}

[type='checkbox'] {
  box-sizing: border-box;
  padding: 0;
}

* {
  box-sizing: border-box;
}

input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

strong {
  font-weight: 600;
}

hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}

hr:after,
hr:before {
  display: table;
  content: '';
}

hr:after {
  clear: both;
}

table {
  border-spacing: 0;
  border-collapse: collapse;
}

td,
th {
  padding: 0;
}

details summary {
  cursor: pointer;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 0;
  margin-bottom: 0;
}

h1 {
  font-size: 32px;
}

h1,
h2 {
  font-weight: 600;
}

h2 {
  font-size: 24px;
}

h3 {
  font-size: 20px;
}

h3,
h4 {
  font-weight: 600;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h5,
h6 {
  font-weight: 600;
}

h6 {
  font-size: 12px;
}

p {
  margin-top: 0;
  margin-bottom: 10px;
}

blockquote {
  margin: 0;
}

ol,
ul {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

ol ol,
ul ol {
  list-style-type: lower-roman;
}

ol ol ol,
ol ul ol,
ul ol ol,
ul ul ol {
  list-style-type: lower-alpha;
}

dd {
  margin-left: 0;
}

code,
pre {
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
}

pre {
  margin-top: 0;
  margin-bottom: 0;
}

input::-webkit-inner-spin-button,
input::-webkit-outer-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

:checked + .radio-label {
  position: relative;
  z-index: 1;
  border-color: #0366d6;
}

.border {
  border: 1px solid #e1e4e8 !important;
}

.border-0 {
  border: 0 !important;
}

.border-bottom {
  border-bottom: 1px solid #e1e4e8 !important;
}

.rounded-1 {
  border-radius: 3px !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-gray-light {
  background-color: #fafbfc !important;
}

.text-gray-light {
  color: #6a737d !important;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-top: 8px !important;
  margin-bottom: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3,
.px-3 {
  padding-left: 16px !important;
}

.px-3 {
  padding-right: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.f6 {
  font-size: 12px !important;
}

.lh-condensed {
  line-height: 1.25 !important;
}

.text-bold {
  font-weight: 600 !important;
}

.pl-c {
  color: #6a737d;
}

.pl-c1,
.pl-s .pl-v {
  color: #005cc5;
}

.pl-e,
.pl-en {
  color: #6f42c1;
}

.pl-s .pl-s1,
.pl-smi {
  color: #24292e;
}

.pl-ent {
  color: #22863a;
}

.pl-k {
  color: #d73a49;
}

.pl-pds,
.pl-s,
.pl-s .pl-pse .pl-s1,
.pl-sr,
.pl-sr .pl-cce,
.pl-sr .pl-sra,
.pl-sr .pl-sre {
  color: #032f62;
}

.pl-smw,
.pl-v {
  color: #e36209;
}

.pl-bu {
  color: #b31d28;
}

.pl-ii {
  color: #fafbfc;
  background-color: #b31d28;
}

.pl-c2 {
  color: #fafbfc;
  background-color: #d73a49;
}

.pl-c2:before {
  content: '^M';
}

.pl-sr .pl-cce {
  font-weight: 700;
  color: #22863a;
}

.pl-ml {
  color: #735c0f;
}

.pl-mh,
.pl-mh .pl-en,
.pl-ms {
  font-weight: 700;
  color: #005cc5;
}

.pl-mi {
  font-style: italic;
  color: #24292e;
}

.pl-mb {
  font-weight: 700;
  color: #24292e;
}

.pl-md {
  color: #b31d28;
  background-color: #ffeef0;
}

.pl-mi1 {
  color: #22863a;
  background-color: #f0fff4;
}

.pl-mc {
  color: #e36209;
  background-color: #ffebda;
}

.pl-mi2 {
  color: #f6f8fa;
  background-color: #005cc5;
}

.pl-mdr {
  font-weight: 700;
  color: #6f42c1;
}

.pl-ba {
  color: #586069;
}

.pl-sg {
  color: #959da5;
}

.pl-corl {
  text-decoration: underline;
  color: #032f62;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-bottom: 8px !important;
}

.my-2 {
  margin-top: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3 {
  padding-left: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.pl-7 {
  padding-left: 48px !important;
}

.pl-8 {
  padding-left: 64px !important;
}

.pl-9 {
  padding-left: 80px !important;
}

.pl-10 {
  padding-left: 96px !important;
}

.pl-11 {
  padding-left: 112px !important;
}

.pl-12 {
  padding-left: 128px !important;
}

hr {
  border-bottom-color: #eee;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

body:after,
body:before {
  display: table;
  content: '';
}

body:after {
  clear: both;
}

body > :first-child {
  margin-top: 0 !important;
}

body > :last-child {
  margin-bottom: 0 !important;
}

a:not([href]) {
  color: inherit;
  text-decoration: none;
}

blockquote,
details,
dl,
ol,
p,
pre,
table,
ul {
  margin-top: 0;
  margin-bottom: 16px;
}

hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}

blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
}

blockquote > :first-child {
  margin-top: 0;
}

blockquote > :last-child {
  margin-bottom: 0;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h1 {
  font-size: 2em;
}

h1,
h2 {
  padding-bottom: 0.3em;
  border-bottom: 1px solid #eaecef;
}

h2 {
  font-size: 1.5em;
}

h3 {
  font-size: 1.25em;
}

h4 {
  font-size: 1em;
}

h5 {
  font-size: 0.875em;
}

h6 {
  font-size: 0.85em;
  color: #6a737d;
}

ol,
ul {
  padding-left: 2em;
}

ol ol,
ol ul,
ul ol,
ul ul {
  margin-top: 0;
  margin-bottom: 0;
}

li {
  word-wrap: break-all;
}

li > p {
  margin-top: 16px;
}

li + li {
  margin-top: 0.25em;
}

dl {
  padding: 0;
}

dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

table {
  display: block;
  width: 100%;
  overflow: auto;
}

table th {
  font-weight: 600;
}

table td,
table th {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

img {
  max-width: 80%;
  box-sizing: initial;
  display: block;
  margin-left: auto;
  margin-right: auto;
  background-color: #fff;
}

code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27, 31, 35, 0.05);
  border-radius: 3px;
}

pre {
  word-wrap: normal;
}

pre > code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  -webkit-print-color-adjust: exact;
  background: #f8f8f8;
}

.hljs pre {
  margin-bottom: 0;
  word-break: normal;
}

.hljs pre,
pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  -webkit-print-color-adjust: exact;

  border-radius: 3px;
}

pre code {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: initial;
  border: 0;
}

.commit-tease-sha {
  display: inline-block;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 90%;
  color: #444d56;
}

.full-commit .btn-outline:not(:disabled):hover {
  color: #005cc5;
  border-color: #005cc5;
}

.blob-wrapper {
  overflow-x: auto;
  overflow-y: hidden;
}

.blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.blob-num {
  width: 1%;
  min-width: 50px;
  padding-right: 10px;
  padding-left: 10px;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  line-height: 20px;
  color: rgba(27, 31, 35, 0.3);
  text-align: right;
  white-space: nowrap;
  vertical-align: top;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.blob-num:hover {
  color: rgba(27, 31, 35, 0.6);
}

.blob-num:before {
  content: attr(data-line-number);
}

.blob-code {
  position: relative;
  padding-right: 10px;
  padding-left: 10px;
  line-height: 20px;
  vertical-align: top;
}

.blob-code-inner {
  overflow: visible;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  color: #24292e;
  word-wrap: normal;
  white-space: pre;
}

.pl-token.active,
.pl-token:hover {
  cursor: pointer;
  background: #ffea7f;
}

.tab-size[data-tab-size='1'] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.tab-size[data-tab-size='2'] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.tab-size[data-tab-size='3'] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.tab-size[data-tab-size='4'] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.tab-size[data-tab-size='5'] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.tab-size[data-tab-size='6'] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.tab-size[data-tab-size='7'] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.tab-size[data-tab-size='8'] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.tab-size[data-tab-size='9'] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.tab-size[data-tab-size='10'] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.tab-size[data-tab-size='11'] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.tab-size[data-tab-size='12'] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.task-list-item {
  list-style-type: none;
}

.task-list-item + .task-list-item {
  margin-top: 3px;
}

.task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}
/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/
  
  .hljs-comment,
  .hljs-quote {
    color: #998;
    font-style: italic;
  }
  
  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-subst {
    color: #333;
    font-weight: bold;
  }
  
  .hljs-number,
  .hljs-literal,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-tag .hljs-attr {
    color: #008080;
  }
  
  .hljs-string,
  .hljs-doctag {
    color: #d14;
  }
  
  .hljs-title,
  .hljs-section,
  .hljs-selector-id {
    color: #900;
    font-weight: bold;
  }
  
  .hljs-subst {
    font-weight: normal;
  }
  
  .hljs-type,
  .hljs-class .hljs-title {
    color: #458;
    font-weight: bold;
  }
  
  .hljs-tag,
  .hljs-name,
  .hljs-attribute {
    color: #000080;
    font-weight: normal;
  }
  
  .hljs-regexp,
  .hljs-link {
    color: #009926;
  }
  
  .hljs-symbol,
  .hljs-bullet {
    color: #990073;
  }
  
  .hljs-built_in,
  .hljs-builtin-name {
    color: #0086b3;
  }
  
  .hljs-meta {
    color: #999;
    font-weight: bold;
  }
  
  .hljs-deletion {
    background: #fdd;
  }
  
  .hljs-addition {
    background: #dfd;
  }
  
  .hljs-emphasis {
    font-style: italic;
  }
  
  .hljs-strong {
    font-weight: bold;
  }
		</style>
<script> MathJax = { tex: { inlineMath: [["$", "$"]] } }; </script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
	</head>
	<body>
		<nav id="table-of-contents">
			<ul><li><a href="#template-in-c"> Template in C++</a><ul><li><a href="#template-di-funzione"> Template di funzione</a><ul><li><a href="#istanziazione-di-un-template-di-funzione"> Istanziazione di un template di funzione</a></li><li><a href="#nota-bene"> Nota bene</a></li><li><a href="#una-utile-analogia"> Una utile analogia</a></li><li><a href="#specializzazione-esplicita-di-un-template-di-funzione"> Specializzazione esplicita di un template di funzione</a></li></ul></li><li><a href="#instanziazioni-esplicite-di-template"> Instanziazioni esplicite di template</a></li><li><a href="#template-di-classe"> Template di classe</a><ul><li><a href="#istanziazione-on-demand"> Istanziazione on demand</a></li><li><a href="#istanziazioni-e-specializzazioni-di-template-di-classe"> Istanziazioni e specializzazioni di template di classe</a></li><li><a href="#specializzazioni-parziali"> Specializzazioni parziali</a></li><li><a href="#unaltra-analogia"> Un'altra analogia</a></li></ul></li><li><a href="#altri-template"> Altri template</a></li><li><a href="#compilazione-dei-template"> Compilazione dei template</a><ul><li><a href="#conseguenza-1"> Conseguenza 1</a></li><li><a href="#conseguenza-2"> Conseguenza 2</a></li></ul></li></ul></li></ul>
		</nav>
		<main>
			<h1 id="template-in-c" tabindex="-1"><a class="anchor" href="#template-in-c" aria-hidden="true"><span class="octicon octicon-link"></span></a> Template in C++</h1>
<pre><code class="language-toc"></code></pre>
<hr>
<h2 id="template-di-funzione" tabindex="-1"><a class="anchor" href="#template-di-funzione" aria-hidden="true"><span class="octicon octicon-link"></span></a> Template di funzione</h2>
<p><mark style="background: #ABF7F7A6;">Un template di funzione è un costrutto del linguggio $C$++ che consente di scrivere un <em>modello</em> (schema) parametrico per una funzione.</mark></p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// dichiarazione pura di un template di funzione</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>;

<span class="hljs-comment">// definizione di un template di funzione</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> </span>{
	  <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;
}
</code></pre>
<p>Nell'esempio precedente abbiamo prima dichiarato e poi definito un template di funzione di nome <code>max</code>.</p>
<blockquote>
<p>Come al solito, la definizione è anche una dichiarazione.</p>
</blockquote>
<p>Nell'esempio, <code>T</code> è un parametro di template: il parametro viene dichiarato essere un <code>typename</code>(nome di tipo) nella lista dei parametri del template.
La parola chiave "<em>typename</em>" può essere sostituita da "<em>class</em>", ma in ogni caso indica un qualunque tipo di dato, anche built-in (quindi per  coerenza si dovrebbe preferire l'uso di "typename").
La lista dei parametri può contenerne un numero arbitrario, separati da virgole; oltre ai parametri che sono nomi di tipo, vedremo che esistono anche altre tipologie (valori, template).</p>
<blockquote>
<p>Si noti che per convenzione (non è una regola del linguaggio) si usano nomi maiuscoli per i parametri di tipo; il nome "T" è comunque arbitrario (e può essere cambiato a piacere): è stato scelto, probabilmente, per indicare che si intende un tipo qualunque.</p>
</blockquote>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span></span>; <span class="hljs-comment">// dichiara la stessa funzione foo</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-function">U <span class="hljs-title">max</span><span class="hljs-params">(U x, U y)</span></span>; <span class="hljs-comment">// dichiara lo stesso template max</span>
</code></pre>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="istanziazione-di-un-template-di-funzione" tabindex="-1"><a class="anchor" href="#istanziazione-di-un-template-di-funzione" aria-hidden="true"><span class="octicon octicon-link"></span></a> Istanziazione di un template di funzione</h3>
<p>Dato un template di funzione, è possibile "generare" da esso una o più funzioni mediante il meccanismo di istanziazione (del template): l'istanziazione fornisce un <em>argomento</em> (della tipologia corretta) ad ognuno dei parametri del template.</p>
<p>L'istanziazione avviene spesso in maniera <em>implicita</em>, quando si fa riferimento al nome del template allo scopo di "usarne" una particolare istanza. Nell'esempio seguente, il template <code>max</code> viene istanziato (implicitamente) due volte, usando le parentesi angolate per fornire (esplicitamente) l'argomento per il parametro del template.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, <span class="hljs-keyword">double</span> d1, <span class="hljs-keyword">double</span> d2)</span> </span>{
  <span class="hljs-comment">// istanziazione della funzione</span>
  <span class="hljs-comment">//   int max&lt;int&gt;(int, int);</span>
  <span class="hljs-keyword">int</span> m = max&lt;<span class="hljs-keyword">int</span>&gt;(i1, i2);

  <span class="hljs-comment">// istanziazione della funzione</span>
  <span class="hljs-comment">//   double max&lt;double&gt;(double, double)</span>
  <span class="hljs-keyword">double</span> d = max&lt;<span class="hljs-keyword">double</span>&gt;(d1, d2);
}
</code></pre>
<p>Quando si istanzia un template di funzione, è possibile evitare la sintassi esplicita per gli argomenti del template, lasciando al compilatore il compito di <em>dedurre</em> tali argomenti a partire dal tipo degli argomenti passati alla chiamata di funzione.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c1, <span class="hljs-keyword">char</span> c2)</span> </span>{
  <span class="hljs-comment">// istanziazione della funzione</span>
  <span class="hljs-comment">//   char max&lt;char&gt;(char, char);</span>
  <span class="hljs-keyword">int</span> m = <span class="hljs-built_in">max</span>(c1, c2);
  <span class="hljs-comment">// il legame T = char viene dedotto dal tipo degli argomenti c1 e c2;</span>
  <span class="hljs-comment">// si noti che il tipo di m (int) non influisce sul processo di deduzione</span>
}
</code></pre>
<p>Il processo di deduzione potrebbe fallire a causa di ambiguità:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d, <span class="hljs-keyword">int</span> i)</span> </span>{
  <span class="hljs-keyword">int</span> m = <span class="hljs-built_in">max</span>(d, i); <span class="hljs-comment">// errore</span>
  <span class="hljs-comment">// il compilatore non può dedurre un unico tipo T coerente con d e i</span>
  <span class="hljs-keyword">int</span> m = max&lt;<span class="hljs-keyword">int</span>&gt;(d, i); <span class="hljs-comment">// ok: evito la deduzione</span>
}
</code></pre>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="nota-bene" tabindex="-1"><a class="anchor" href="#nota-bene" aria-hidden="true"><span class="octicon octicon-link"></span></a> Nota bene</h3>
<p><u>È opportuno sottolineare la differenza sostanziale tra un template di funzione e le sue possibili istanziazioni.</u> In particolare: un template di funzione NON è una funzione (è un "generatore" di funzioni); una istanza di un template di funzione è una funzione.</p>
<p>Per esempio, NON posso prendere l'indirizzo di un template di funzione (posso prendere l'indirizzo di una istanza specifica); non posso effettuare una chiamata di un template (chiamo una istanza specifica); non posso passare un template come argomento ad una funzione (passo una istanza specifica, che corrisponde a passarne l'indirizzo usando il type decay).</p>
<p>Se compilo una unità di traduzione ottenendo un object file e osservo il contenuto dell'object file con il comando <code>nm</code>, vedrò solo le <em>istanze</em> dei template di funzione (non vedrò i template di funzione).</p>
<p>Fatta questa doverosa sottolineatura, va comunque detto che nel linguaggio comune spesso si parla di "chiamata di un template di funzione" per indicare la chiamata di una sua specifica istanza.</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="una-utile-analogia" tabindex="-1"><a class="anchor" href="#una-utile-analogia" aria-hidden="true"><span class="octicon octicon-link"></span></a> Una utile analogia</h3>
<p>A livello intuitivo può essere utile fare la seguente analogia.
Sui siti web dei corsi di laurea sono spesso resi disponibili dei moduli per compilare una domanda di modifica di piano di studio.</p>
<p>Questi moduli sono dei "modelli" di domanda, parametrici, e corrispondono al concetto di template: in essi sono lasciati degli spazi (i parametri) che devono essere compilati con i dati dello studente per produrre una (vera e propria) domanda di modifica di piano di studio.</p>
<p>Il processo di istanziazione corrisponde alla compilazione del modulo: ad ogni parametro si associa il corrispondente argomento. Il modulo compilato corrisponde quindi all'istanza del template. Alla segreteria studenti occorre fare avere l'istanza (il modulo compilato), in quanto del template (il modulo in bianco) non saprebbero che farsene.</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="specializzazione-esplicita-di-un-template-di-funzione" tabindex="-1"><a class="anchor" href="#specializzazione-esplicita-di-un-template-di-funzione" aria-hidden="true"><span class="octicon octicon-link"></span></a> Specializzazione esplicita di un template di funzione</h3>
<p>Capita a volte che la definizione di un template di funzione sia adeguata per molti, ma non per tutti i casi di interesse; ad esempio, il codice scritto potrebbe fornire un risultato ritenuto sbagliato quando ai parametri del template sono associati argomenti particolari.</p>
<p>Ad esempio, il template <code>max</code> può essere istanziato anche con il tipo <code>const char*</code>, ottenendo una funzione che restituisce il massimo dei due puntatori passati, quando invece, molto probabilmente, le intenzioni dell'utente era di fare un confronto lessicografico tra due stringhe stile $C$.</p>
<p>Per ovviare, è possibile fornire una definizione alternativa della funzione templatica, "specializzata" per gli argomenti problematici, nel modo seguente:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// definizione del template</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> </span>{
  <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;
}

<span class="hljs-comment">// specializzazione esplicita (per T = const char*) del template</span>
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* max&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a, b) &gt; <span class="hljs-number">0</span>;
}
</code></pre>
<p>A livello sintattico, si noti la lista vuota dei parametri <code>&lt;&gt;</code>, ad indicare che si tratta di una specializzazione <em>totale</em> (non sono ammesse specializzazioni parziali per i template di funzione).</p>
<p>Anche in questo caso è possibile omettere la lista degli argomenti <code>&lt;const char*&gt;</code>, lasciando che venga dedotta dal compilatore.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span> </span>{ ... }
</code></pre>
<p>Si noti che sarebbe comunque stato possibile evitare la specializzazione del template e fornire la versione specifica per i <code>const char*</code> come funzione "normale", sfruttando l'overloading di funzioni:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span></span>;
</code></pre>
<p>Diventa quindi importante capire come si comporta il meccanismo di risoluzione dell'overloading in questi casi (l'approfondimento verrà effettuato successivamente).</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="instanziazioni-esplicite-di-template" tabindex="-1"><a class="anchor" href="#instanziazioni-esplicite-di-template" aria-hidden="true"><span class="octicon octicon-link"></span></a> Instanziazioni esplicite di template</h2>
<p>Abbiamo visto che per un template è possibile fornire istanziazioni implicite (date dall'uso del template) e specializzazioni esplicite.
Esiste anche la possibilità di richiedere <em>esplicitamente</em> al compilatore l'istanziazione di un template, indipendentemente dal fatto che questo venga effettivamente utilizzato.</p>
<p>Son previste due sintassi, corrispondenti a due casi di uso distinti (che tipicamente occorrono in unità di traduzione diverse facenti parte della stessa applicazione).</p>
<ol>
<li>Dichiarazione di istanziazione esplicita</li>
</ol>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span>
<span class="hljs-keyword">float</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a, <span class="hljs-keyword">float</span> b)</span></span>;
</code></pre>
<ol start="2">
<li>Definizione di istanziazione esplicita</li>
</ol>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>
<span class="hljs-keyword">float</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a, <span class="hljs-keyword">float</span> b)</span></span>;
</code></pre>
<p>A livello sintattico, si noti l'assenza della lista dei parametri (la parola chiave <code>template</code> NON è seguita da parentesi angolate): questo differenzia le istanziazioni esplicite dalle specializzazioni esplicite.</p>
<p>Il caso 1 (dichiarazione) informa il compilatore che, quando verrà usata quella istanza del template, NON deve essere prodotta la corrispondente definizione dell'istanza (evitando quindi la generazione del codice).
Intuitivamente, la parola chiave <code>extern</code> indica che il codice dovrà essere trovato dal linker "esternamente" a questa unità di traduzione, cioè in un object file generato dalla compilazione di un'altra unità di traduzione. In pratica, la <em>dichiarazione</em> di istanziazione esplicita impedisce che vengano effettuate le istanziazioni implicite (per diminuire i tempi di compilazione e/o generare object file più piccoli).</p>
<p>Il caso 2 (definizione) è complementare al caso 1: si informa il compilatore che quella particolare istanza del template va generata, a prescindere dal fatto che in questa unità di traduzione ne venga o meno effettuato l'utilizzo. Serve ad assicurarsi che le altre unità di traduzione (che hanno usato il caso 1) possano essere collegate con successo.</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="template-di-classe" tabindex="-1"><a class="anchor" href="#template-di-classe" aria-hidden="true"><span class="octicon octicon-link"></span></a> Template di classe</h2>
<p><mark style="background: #BBFABBA6;">Un template di classe è un costrutto del linguggio che consente di scrivere un <em>modello</em> parametrico per una classe.</mark></p>
<p>Quasi tutti i concetti esposti per il caso dei template di funzione possono essere applicati alle classi: nel seguito si sottolineano le differenze (poche ma importanti).</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// dichiarazione pura di un template di classe</span>
<span class="hljs-comment">// (nota: il nome T del parametro potrebbe essere omesso)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>;</span>

<span class="hljs-comment">// definizione di un template di classe</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">/* ... */</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; t)</span></span>;
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;
	<span class="hljs-comment">/* ... */</span>
};
</code></pre>
<p>Nel caso dei template di classe, è ancora più importante distinguere tra il nome del template (<code>Stack</code>) e il nome di una specifica istanza (per esempio, <code>Stack&lt;std::string&gt;</code>). Infatti, per i template di classe NON si applica la deduzione dei parametri del template: la lista degli argomenti va indicata obbligatoriamente.</p>
<pre><code class="language-cpp">Stack&lt;<span class="hljs-keyword">int</span>&gt; s1; <span class="hljs-comment">// istanziazione implicita del tipo Stack&lt;int&gt;</span>
	           <span class="hljs-comment">// (in particolare, del costruttore di default)</span>
	           
Stack s2 = s1; <span class="hljs-comment">// errore: non viene dedotto il tipo T = int</span>

<span class="hljs-keyword">auto</span> s2 = s1;  <span class="hljs-comment">// ok: il C++11 ha introdotto la deduzione di tipo</span>
               <span class="hljs-comment">// dall'inizializzatore, usando `auto`; viene anche</span>
               <span class="hljs-comment">// istanziato implicitamente il costruttore di copia</span>
</code></pre>
<p>L'unico caso in cui è lecito usare il nome del template di classe per indicare (in realtà) il nome della classe ottenuta mediante istanziazione è all'interno dello scope del template di classe stesso.</p>
<p>Per esempio:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> {</span>
	<span class="hljs-comment">/* ... */</span>
	<span class="hljs-comment">/* qui gli usi di Stack sono abbreviazioni (lecite) di Stack&lt;T&gt; */</span>
	Stack&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Stack&amp;);
	<span class="hljs-comment">/* ... */</span>
}; <span class="hljs-comment">// usciamo dallo scope di classe</span>

<span class="hljs-comment">// definizione (out-of-line)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
Stack&lt;T&gt;&amp; <span class="hljs-comment">// il tipo di ritorno è fuori scope di classe, devo scrivere &lt;T&gt;</span>
Stack&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Stack&amp; y) { <span class="hljs-comment">// parametro in scope di classe</span>
	Stack tmp = y; <span class="hljs-comment">// in scope di classe, è sufficiente Stack</span>
	<span class="hljs-built_in">swap</span>(tmp);
	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="istanziazione-on-demand" tabindex="-1"><a class="anchor" href="#istanziazione-on-demand" aria-hidden="true"><span class="octicon octicon-link"></span></a> Istanziazione on demand</h3>
<p>E' importante sottolineare che, quando si istanzia implicitamente una classe templatica, vengono generate solo le funzionalità necessarie per il funzionamento del codice che causa l'istanziazione.
Quindi, nell'esempio precedente, per la classe <code>Stack&lt;int&gt;</code> NON vengono istanziati i metodi <code>Stack&lt;int&gt;::push(const int&amp;)</code> e <code>Stack&lt;int&gt;::pop()</code>.
Verranno istanziati se e quando utilizzati.</p>
<p>Questo scelta del linguaggio ha conseguenze positive e negative:</p>
<ul>
<li>In negativo: quando scrivo i test per la classe templatica devo prestare attenzione a fornire un insieme di test che copra tutte le funzionalità di interesse; le funzionalità NON testate (e quindi non instanziate) potrebbero addirittura generare errori di compilazione al momento dell'instanziazione da parte dell'utente.</li>
<li>In positivo: per lo stesso motivo, posso usare un sotto-insieme delle funzionalità della classe istanziandola con argomenti che soddisfano solo i requisiti di quelle funzionalità; il fatto che quegli argomenti siano "scorretti" per le altre funzionalità (non usate) non mi impedisce l'utilizzo dell'interfaccia "ristretta".</li>
</ul>
<p>Esempio:
Supponiamo che la classe <code>Stack&lt;T&gt;</code> fornisca un metodo <code>print()</code>, implementato invocando il corrispondente metodo <code>print()</code> del parametro <code>T</code> su ognuno degli oggetti contenuti nello stack. Questo significa che, per usare il metodo <code>Stack&lt;T&gt;::print()</code>, il tipo <code>T</code> <u><em>deve</em></u> fornire a sua volta il metodo <code>T::print()</code> .</p>
<blockquote>
<p>Si noti, per esempio, che "int" non è una classe e quindi un tentativo di istanziare <code>Stack&lt;int&gt;::print()</code> genera un errore di compilazione. L'errore, però, lo si ottiene <em>solo</em> se effettivamente si prova a istanziare <code>Stack&lt;int&gt;::print();</code> l'istanziazione dei metodi <code>Stack&lt;int&gt;::push()</code> e <code>Stack&lt;int&gt;::pop()</code> continua ad essere corretta e utilizzabile.</p>
</blockquote>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="istanziazioni-e-specializzazioni-di-template-di-classe" tabindex="-1"><a class="anchor" href="#istanziazioni-e-specializzazioni-di-template-di-classe" aria-hidden="true"><span class="octicon octicon-link"></span></a> Istanziazioni e specializzazioni di template di classe</h3>
<p>Come nel caso dei template di funzione, anche i template di classe possono essere istanziati (implicitamente o esplicitamente) e specializzati.</p>
<p>Un esempio di specializzazione <em>totale</em> di template di classe è fornito all'interno dell'header file standard <code>&lt;limits&gt;</code>, che fornisce il template di classe <code>std::numeric_limits</code>, attraverso il quale si possono per esempio ottenere informazioni sui tipi built-in.</p>
<p>Esempio di uso:</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-keyword">long</span> minimo = std::numeric_limits&lt;<span class="hljs-keyword">long</span>&gt;::<span class="hljs-built_in">min</span>();
	<span class="hljs-keyword">long</span> massimo = std::numeric_limits&lt;<span class="hljs-keyword">long</span>&gt;::<span class="hljs-built_in">max</span>();
	<span class="hljs-keyword">bool</span> char_con_segno = std::numeric_limits&lt;<span class="hljs-keyword">char</span>&gt;::is_signed;
}
</code></pre>
<p>Nell'header file limits troviamo, tra le altre cose, le specializzazioni totali che consentono di rispondere alle interrogazioni dell'utente:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// [...]</span>
<span class="hljs-comment">// numeric_limits&lt;char&gt; specialization.</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">numeric_limits</span>&lt;</span><span class="hljs-keyword">char</span>&gt;
<span class="hljs-comment">// [...]</span>
<span class="hljs-comment">// numeric_limits&lt;long&gt; specialization.</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">numeric_limits</span>&lt;</span><span class="hljs-keyword">long</span>&gt;
<span class="hljs-comment">// [...]</span>
</code></pre>
<p>Un altro esempio è dato dalla specializzazione <code>std::vector&lt;bool&gt;</code> del template <code>std::vector</code>, creata allo scopo di fornire una versione del contenitore ottimizzata per risparmiare memoria (codificando ogni valore booleano con un singolo bit).</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="specializzazioni-parziali" tabindex="-1"><a class="anchor" href="#specializzazioni-parziali" aria-hidden="true"><span class="octicon octicon-link"></span></a> Specializzazioni parziali</h3>
<p>A differenza dei template di funzione, i template di classe supportano anche le <em>specializzazioni parziali</em>. <mark style="background: #FFB8EBA6;">Si tratta di specializzazioni di template che sono applicabili non per una scelta specifica degli argomenti</mark> (come nel caso delle specializzazioni totali), <mark style="background: #FFB8EBA6;">ma per sottoinsiemi di tipi.</mark>
Una specializzazione parziale di un template (di classe), quindi, è ancora un template di classe, ma di applicabilità meno generale.</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="unaltra-analogia" tabindex="-1"><a class="anchor" href="#unaltra-analogia" aria-hidden="true"><span class="octicon octicon-link"></span></a> Un'altra analogia</h3>
<p>Riprendiamo l'analogia dei moduli per la domanda di modifica di piano di studi: si era detto che il modulo in bianco è il template (per uno studente qualsiasi) e il modulo compilato in ogni sua parte è l'istanza (di uno specifico studente).</p>
<p>Una specializzazione esplicita <em>totale</em> corrisponde ad una domanda di modifica di piano degli studi "fuori standard", fatta (ad personam) da uno specifico studente e che non segue necessariamente lo schema del modello generale.</p>
<p>Una specializzazione <em>parziale</em>, invece, corrisponde ad un modulo diverso (quindi è ancora un template), che però viene utilizzato solo da uno specifico sottoinsieme degli studenti (per esempio, gli studenti iscritti alle lauree magistrali a ciclo unico). Quando uno studente di Medicina e Chirurgia chiede il modulo da compilare, gli si fornisce il modulo specializzato (parzialmente): per ottenere la domanda vera e propria dovrà compilare (istanziare) il modulo specializzato.</p>
<p>Gli esempi di specializzazione parziale di template di classe sono meno frequenti (anche nella libreria standard). Tra di essi tratteremo (quando affronteremo gli iteratori) il caso della specializzazione parziale per i puntatori degli <code>std::iterator_traits</code>.
Nell'header file <code>&lt;iterator&gt;</code> (in realtà, in un header file interno che dipende dalla specifica implementazione) troviamo:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// Partial specialization for pointer types.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iterator_traits</span>&lt;</span>_Tp*&gt;
<span class="hljs-comment">/* ... */</span>
</code></pre>
<p>Il fatto che si tratti di una specializzazione parziale si deduce dalla contemporanea presenza della lista (non vuota) dei parametri del template e della lista (non vuota) degli argomenti del template, nella quale si nomina ancora il parametro del template.</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="altri-template" tabindex="-1"><a class="anchor" href="#altri-template" aria-hidden="true"><span class="octicon octicon-link"></span></a> Altri template</h2>
<p>Gli standard più recenti hanno introdotto nuove forme di template, sui quali non faremo approfondimenti.</p>
<p>Template di alias:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> Vec&lt;T&gt; = std::vector&lt;T, std::allocator&lt;T&gt;&gt;;
</code></pre>
<p>Template di variabile:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">const</span> T pi = <span class="hljs-built_in">T</span>(<span class="hljs-number">3.1415926535897932385L</span>);
</code></pre>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="compilazione-dei-template" tabindex="-1"><a class="anchor" href="#compilazione-dei-template" aria-hidden="true"><span class="octicon octicon-link"></span></a> Compilazione dei template</h2>
<p>Il processo di compilazione dei template richiede che lo stesso codice sia analizzato dal compilatore in (almeno) due contesti distinti:</p>
<ol>
<li>al momento della definizione del template, e</li>
<li>al momento della instanziazione del template.</li>
</ol>
<p>Nella prima fase (definizione del template) il compilatore si trova ad operare con informazione incompleta. Si consideri il seguente esempio:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incr</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; i, T&amp; t)</span> </span>{
	++i; <span class="hljs-comment">// espressione indipendente dai parametri del template</span>
	++t; <span class="hljs-comment">// espressione dipendente dai parametri del template</span>
}
</code></pre>
<p>Sulla prima espressione il compilatore può effettuare tutti i controlli di correttezza previsti (sintattici e di semantica statica) e nulla vieterebbe di generare una porzione del codice oggetto.</p>
<p>Sulla seconda espressione, invece, gli unici controlli che possono essere effettuati sono dei banali controlli sintattici: non c'è modo per il compilatore di sapere se il tipo T fornisce effettivamente un operatore di preincremento. Questo controllo (e la segnalazione di eventuali errori) viene quindi "rimandato" alla successiva fase di instanziazione del template.</p>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="conseguenza-1" tabindex="-1"><a class="anchor" href="#conseguenza-1" aria-hidden="true"><span class="octicon octicon-link"></span></a> Conseguenza 1</h3>
<p><mark style="background: #D2B3FFA6;">Una prima conseguenza, di cui tenere conto quando si scrivono i programmi, è che la definizione di un template deve essere disponibile i tutti i punti del programma nei quali se ne richiede l'istanziazione.</mark></p>
<p>In pratica, esistono tre modi per organizzare il codice sorgente quando si scrivono funzioni o classi templatiche:</p>
<ol>
<li>
<p>Includere le definizioni dei template (comprese la definizioni di eventuali funzioni membro dei template di classe) prima di ogni loro uso nella unità di traduzione.</p>
</li>
<li>
<p>Includere le dichiarazioni del template (comprese le dichiarazioni delle eventuali funzioni membro dei template di classe) prima di farne uso e successivamente (prima o dopo gli usi) includere le definizioni del template nella unità di traduzione.</p>
</li>
<li>
<p>Sfruttando il meccanismo delle istanziazioni esplicite, includere solo le dichiarazioni dei template e le <em>dichiarazioni</em> di istanziazione esplicita prima di ogni loro uso nell'unità di traduzione, assicurandosi che le definizioni dei template e le <em>definizioni</em> di istanziazione esplicita siano fornite in un'altra unità di traduzione.</p>
</li>
</ol>
<p>L'approccio più comune, perché più semplice, è il primo. Il secondo approccio si usa solo quando necessario (per esempio, nel caso di funzioni templatiche che si invocano l'un l'altra ricorsivamente). Il terzo approccio è usato raramente, tipicamente al solo scopo di diminuire i tempi di compilazione.</p>
<blockquote>
<p>Si noti che, nell'esercitazione sulla templatizzazione della classe Stack, abbiamo seguito il primo approccio, spostando tutte le definizioni dei metodi della classe all'interno dell'header file Stack.hh.</p>
</blockquote>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="conseguenza-2" tabindex="-1"><a class="anchor" href="#conseguenza-2" aria-hidden="true"><span class="octicon octicon-link"></span></a> Conseguenza 2</h3>
<p>Una seconda conseguenza del meccanismo di compilazione in due fasi dei template è che, in alcuni casi, <mark style="background: #D2B3FFA6;">occorre modificare il codice di implementazione dei template di funzioni o classe per fornire al compilatore qualche informazione utile ad evitare errori di compilazione.</mark></p>
<p>Per esempio, consideriamo il seguente codice (non templatico):</p>
<pre><code class="language-cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span>
	<span class="hljs-keyword">using</span> value_type = <span class="hljs-comment">/* ... dettaglio implementativo ... */</span>;
	<span class="hljs-comment">/* ... */</span>
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> S&amp; s)</span> </span>{
	S::value_type* ptr;
	<span class="hljs-comment">/* ... */</span>
}
</code></pre>
<p>Supponiamo ora di voler templatizzare la classe <code>S</code>, rendendola parametrica rispetto ad un qualche tipo usato al suo interno. Intuitivamente, il processo di "lifting" porterebbe ad adattare il codice in questo modo:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span>
	<span class="hljs-keyword">using</span> value_type = <span class="hljs-comment">/* ... dettaglio implementativo ... */</span>;
	<span class="hljs-comment">/* ... */</span>
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> S&lt;T&gt;&amp; s)</span> </span>{
	S&lt;T&gt;::value_type* ptr;   <span class="hljs-comment">// errore: ptr non dichiarato</span>
	<span class="hljs-comment">/* ... */</span>
}
</code></pre>
<p>Il compilatore segnala un errore quando esamina la definizione del template di funzione foo (nella prima fase della compilazione dei template).
In effetti, il compilatore si trova di fronte a codice del tipo</p>
<pre><code class="language-cpp">nome1 * nome2
</code></pre>
<p>e non sa nulla di <code>nome1</code> e <code>nome2</code>: siccome <code>nome1</code> è dipendente dal parametro template <code>T</code>, il compilatore assume che sia il nome di un "valore" (non di un "tipo"), interpretando l'istruzione come applicazione dell'operatore <code>*</code> binario; viene quindi segnalato un errore perché <code>nome2</code> (che non dipende dal parametro <code>T</code>) non è stato dichiarato.</p>
<p>Per risolvere il problema e comunicare correttamente le nostre intenzioni al compilatore, occorre informarlo che <code>S&lt;T&gt;::value_type</code> indica il nome di un tipo, aggiungendo la parola chiave <code>typename</code>:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> S&lt;T&gt;&amp; s)</span> </span>{
	<span class="hljs-keyword">typename</span> S&lt;T&gt;::value_type* ptr;   <span class="hljs-comment">// ok, dichiaro un puntatore</span>
	<span class="hljs-comment">/* ... */</span>
}
</code></pre>
<blockquote>
<p>NOTA BENE: occorre rendersi conto che la problematica suddetta si potrebbe presentare in maniera subdola. Si consideri per esempio questa variante:</p>
</blockquote>
<pre><code class="language-cpp"><span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> S&lt;T&gt;&amp; s)</span> </span>{
	S&lt;T&gt;::value_type* p;   <span class="hljs-comment">// compila senza errori (operator* binario)</span>
	<span class="hljs-comment">/* ... */</span>
}
</code></pre>
<blockquote>
<p>Per pura sfortuna, esiste una dichiarazione di un intero <code>p</code> visibile quando il compilatore valuta l'istruzione, per cui il compilatore non rileva l'errore (assumendo che il programmatore intenda fare una sorta di moltiplicazione del valore di <code>S&lt;T&gt;::value_type</code> con il valore 10 memorizzato nella variabile <code>p</code> dello scope globale).</p>
</blockquote>
<p><a href="#template%20in%20c++"><em>Torna all'indice</em></a></p>

		</main>
	</body>
</html>
