<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
		<title>07-odr</title>
		<style>
			/* PDF Specific */

@media print {
  body {
    min-width: initial;
    max-width: 100%;
    margin: 0 auto;
  }
}

/* General */

.octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.anchor:focus {
  outline: none;
}

h1 .octicon-link,
h2 .octicon-link,
h3 .octicon-link,
h4 .octicon-link,
h5 .octicon-link,
h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
  text-decoration: none;
}

h1:hover .anchor .octicon-link,
h2:hover .anchor .octicon-link,
h3:hover .anchor .octicon-link,
h4:hover .anchor .octicon-link,
h5:hover .anchor .octicon-link,
h6:hover .anchor .octicon-link {
  visibility: visible;
}

h1:hover .anchor .octicon-link:before,
h2:hover .anchor .octicon-link:before,
h3:hover .anchor .octicon-link:before,
h4:hover .anchor .octicon-link:before,
h5:hover .anchor .octicon-link:before,
h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' width='16' height='16' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z'%3E%3C/path%3E%3C/svg%3E");
}

body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  -webkit-print-color-adjust: exact;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial,
    sans-serif, Apple Color Emoji, Segoe UI Emoji;
  font-size: 16px;
  line-height: 1.5;
  color: #24292e;
  word-wrap: break-word;
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 1rem auto;
}

details {
  display: block;
}

summary {
  display: list-item;
}

a {
  background-color: initial;
}

a:active,
a:hover {
  outline-width: 0;
}

strong {
  font-weight: inherit;
  font-weight: bolder;
}

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

img {
  border-style: none;
}

code,
kbd,
pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

hr {
  box-sizing: initial;
  height: 0;
  overflow: visible;
}

input {
  font: inherit;
  margin: 0;
}

input {
  overflow: visible;
}

[type='checkbox'] {
  box-sizing: border-box;
  padding: 0;
}

* {
  box-sizing: border-box;
}

input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

strong {
  font-weight: 600;
}

hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}

hr:after,
hr:before {
  display: table;
  content: '';
}

hr:after {
  clear: both;
}

table {
  border-spacing: 0;
  border-collapse: collapse;
}

td,
th {
  padding: 0;
}

details summary {
  cursor: pointer;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 0;
  margin-bottom: 0;
}

h1 {
  font-size: 32px;
}

h1,
h2 {
  font-weight: 600;
}

h2 {
  font-size: 24px;
}

h3 {
  font-size: 20px;
}

h3,
h4 {
  font-weight: 600;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h5,
h6 {
  font-weight: 600;
}

h6 {
  font-size: 12px;
}

p {
  margin-top: 0;
  margin-bottom: 10px;
}

blockquote {
  margin: 0;
}

ol,
ul {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

ol ol,
ul ol {
  list-style-type: lower-roman;
}

ol ol ol,
ol ul ol,
ul ol ol,
ul ul ol {
  list-style-type: lower-alpha;
}

dd {
  margin-left: 0;
}

code,
pre {
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
}

pre {
  margin-top: 0;
  margin-bottom: 0;
}

input::-webkit-inner-spin-button,
input::-webkit-outer-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

:checked + .radio-label {
  position: relative;
  z-index: 1;
  border-color: #0366d6;
}

.border {
  border: 1px solid #e1e4e8 !important;
}

.border-0 {
  border: 0 !important;
}

.border-bottom {
  border-bottom: 1px solid #e1e4e8 !important;
}

.rounded-1 {
  border-radius: 3px !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-gray-light {
  background-color: #fafbfc !important;
}

.text-gray-light {
  color: #6a737d !important;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-top: 8px !important;
  margin-bottom: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3,
.px-3 {
  padding-left: 16px !important;
}

.px-3 {
  padding-right: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.f6 {
  font-size: 12px !important;
}

.lh-condensed {
  line-height: 1.25 !important;
}

.text-bold {
  font-weight: 600 !important;
}

.pl-c {
  color: #6a737d;
}

.pl-c1,
.pl-s .pl-v {
  color: #005cc5;
}

.pl-e,
.pl-en {
  color: #6f42c1;
}

.pl-s .pl-s1,
.pl-smi {
  color: #24292e;
}

.pl-ent {
  color: #22863a;
}

.pl-k {
  color: #d73a49;
}

.pl-pds,
.pl-s,
.pl-s .pl-pse .pl-s1,
.pl-sr,
.pl-sr .pl-cce,
.pl-sr .pl-sra,
.pl-sr .pl-sre {
  color: #032f62;
}

.pl-smw,
.pl-v {
  color: #e36209;
}

.pl-bu {
  color: #b31d28;
}

.pl-ii {
  color: #fafbfc;
  background-color: #b31d28;
}

.pl-c2 {
  color: #fafbfc;
  background-color: #d73a49;
}

.pl-c2:before {
  content: '^M';
}

.pl-sr .pl-cce {
  font-weight: 700;
  color: #22863a;
}

.pl-ml {
  color: #735c0f;
}

.pl-mh,
.pl-mh .pl-en,
.pl-ms {
  font-weight: 700;
  color: #005cc5;
}

.pl-mi {
  font-style: italic;
  color: #24292e;
}

.pl-mb {
  font-weight: 700;
  color: #24292e;
}

.pl-md {
  color: #b31d28;
  background-color: #ffeef0;
}

.pl-mi1 {
  color: #22863a;
  background-color: #f0fff4;
}

.pl-mc {
  color: #e36209;
  background-color: #ffebda;
}

.pl-mi2 {
  color: #f6f8fa;
  background-color: #005cc5;
}

.pl-mdr {
  font-weight: 700;
  color: #6f42c1;
}

.pl-ba {
  color: #586069;
}

.pl-sg {
  color: #959da5;
}

.pl-corl {
  text-decoration: underline;
  color: #032f62;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-bottom: 8px !important;
}

.my-2 {
  margin-top: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3 {
  padding-left: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.pl-7 {
  padding-left: 48px !important;
}

.pl-8 {
  padding-left: 64px !important;
}

.pl-9 {
  padding-left: 80px !important;
}

.pl-10 {
  padding-left: 96px !important;
}

.pl-11 {
  padding-left: 112px !important;
}

.pl-12 {
  padding-left: 128px !important;
}

hr {
  border-bottom-color: #eee;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

body:after,
body:before {
  display: table;
  content: '';
}

body:after {
  clear: both;
}

body > :first-child {
  margin-top: 0 !important;
}

body > :last-child {
  margin-bottom: 0 !important;
}

a:not([href]) {
  color: inherit;
  text-decoration: none;
}

blockquote,
details,
dl,
ol,
p,
pre,
table,
ul {
  margin-top: 0;
  margin-bottom: 16px;
}

hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}

blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
}

blockquote > :first-child {
  margin-top: 0;
}

blockquote > :last-child {
  margin-bottom: 0;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h1 {
  font-size: 2em;
}

h1,
h2 {
  padding-bottom: 0.3em;
  border-bottom: 1px solid #eaecef;
}

h2 {
  font-size: 1.5em;
}

h3 {
  font-size: 1.25em;
}

h4 {
  font-size: 1em;
}

h5 {
  font-size: 0.875em;
}

h6 {
  font-size: 0.85em;
  color: #6a737d;
}

ol,
ul {
  padding-left: 2em;
}

ol ol,
ol ul,
ul ol,
ul ul {
  margin-top: 0;
  margin-bottom: 0;
}

li {
  word-wrap: break-all;
}

li > p {
  margin-top: 16px;
}

li + li {
  margin-top: 0.25em;
}

dl {
  padding: 0;
}

dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

table {
  display: block;
  width: 100%;
  overflow: auto;
}

table th {
  font-weight: 600;
}

table td,
table th {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

img {
  max-width: 80%;
  box-sizing: initial;
  display: block;
  margin-left: auto;
  margin-right: auto;
  background-color: #fff;
}

code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27, 31, 35, 0.05);
  border-radius: 3px;
}

pre {
  word-wrap: normal;
}

pre > code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  -webkit-print-color-adjust: exact;
  background: #f8f8f8;
}

.hljs pre {
  margin-bottom: 0;
  word-break: normal;
}

.hljs pre,
pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  -webkit-print-color-adjust: exact;

  border-radius: 3px;
}

pre code {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: initial;
  border: 0;
}

.commit-tease-sha {
  display: inline-block;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 90%;
  color: #444d56;
}

.full-commit .btn-outline:not(:disabled):hover {
  color: #005cc5;
  border-color: #005cc5;
}

.blob-wrapper {
  overflow-x: auto;
  overflow-y: hidden;
}

.blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.blob-num {
  width: 1%;
  min-width: 50px;
  padding-right: 10px;
  padding-left: 10px;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  line-height: 20px;
  color: rgba(27, 31, 35, 0.3);
  text-align: right;
  white-space: nowrap;
  vertical-align: top;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.blob-num:hover {
  color: rgba(27, 31, 35, 0.6);
}

.blob-num:before {
  content: attr(data-line-number);
}

.blob-code {
  position: relative;
  padding-right: 10px;
  padding-left: 10px;
  line-height: 20px;
  vertical-align: top;
}

.blob-code-inner {
  overflow: visible;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  color: #24292e;
  word-wrap: normal;
  white-space: pre;
}

.pl-token.active,
.pl-token:hover {
  cursor: pointer;
  background: #ffea7f;
}

.tab-size[data-tab-size='1'] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.tab-size[data-tab-size='2'] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.tab-size[data-tab-size='3'] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.tab-size[data-tab-size='4'] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.tab-size[data-tab-size='5'] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.tab-size[data-tab-size='6'] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.tab-size[data-tab-size='7'] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.tab-size[data-tab-size='8'] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.tab-size[data-tab-size='9'] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.tab-size[data-tab-size='10'] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.tab-size[data-tab-size='11'] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.tab-size[data-tab-size='12'] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.task-list-item {
  list-style-type: none;
}

.task-list-item + .task-list-item {
  margin-top: 3px;
}

.task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}
/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/
  
  .hljs-comment,
  .hljs-quote {
    color: #998;
    font-style: italic;
  }
  
  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-subst {
    color: #333;
    font-weight: bold;
  }
  
  .hljs-number,
  .hljs-literal,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-tag .hljs-attr {
    color: #008080;
  }
  
  .hljs-string,
  .hljs-doctag {
    color: #d14;
  }
  
  .hljs-title,
  .hljs-section,
  .hljs-selector-id {
    color: #900;
    font-weight: bold;
  }
  
  .hljs-subst {
    font-weight: normal;
  }
  
  .hljs-type,
  .hljs-class .hljs-title {
    color: #458;
    font-weight: bold;
  }
  
  .hljs-tag,
  .hljs-name,
  .hljs-attribute {
    color: #000080;
    font-weight: normal;
  }
  
  .hljs-regexp,
  .hljs-link {
    color: #009926;
  }
  
  .hljs-symbol,
  .hljs-bullet {
    color: #990073;
  }
  
  .hljs-built_in,
  .hljs-builtin-name {
    color: #0086b3;
  }
  
  .hljs-meta {
    color: #999;
    font-weight: bold;
  }
  
  .hljs-deletion {
    background: #fdd;
  }
  
  .hljs-addition {
    background: #dfd;
  }
  
  .hljs-emphasis {
    font-style: italic;
  }
  
  .hljs-strong {
    font-weight: bold;
  }
		</style>
<script> MathJax = { tex: { inlineMath: [["$", "$"]] } }; </script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
	</head>
	<body>
		<nav id="table-of-contents">
			<ul><li><a href="#odr"> ODR</a><ul><li><a href="#odr-one-definition-rule"> ODR: One Definition Rule</a></li><li><a href="#esempi"> Esempi</a><ul><li><a href="#violazione-del-punto-1"> Violazione del punto 1</a></li><li><a href="#violazione-del-punto-2"> Violazione del punto 2</a></li><li><a href="#violazione-del-punto-3"> Violazione del punto 3</a></li><li><a href="#violazione-del-punto-4"> Violazione del punto 4</a><ul><li><a href="#esempio-di-violazione-della-4a"> Esempio di violazione della 4a</a></li><li><a href="#esempio-di-violazione-della-4b"> Esempio di violazione della 4b</a></li></ul></li></ul></li><li><a href="#il-tipo-razionale"> Il tipo Razionale</a><ul><li><a href="#qual-%C3%A8-il-modo-corretto-di-risolvere-questa-situazione"> Qual è il modo corretto di risolvere questa situazione?</a></li></ul></li><li><a href="#costrutti-del-linguaggio"> Costrutti del linguaggio</a><ul><li><a href="#perch%C3%A8"> Perchè?</a></li></ul></li></ul></li></ul>
		</nav>
		<main>
			<h1 id="odr" tabindex="-1"><a class="anchor" href="#odr" aria-hidden="true"><span class="octicon octicon-link"></span></a> ODR</h1>
<pre><code class="language-toc"></code></pre>
<hr>
<h2 id="odr-one-definition-rule" tabindex="-1"><a class="anchor" href="#odr-one-definition-rule" aria-hidden="true"><span class="octicon octicon-link"></span></a> ODR: One Definition Rule</h2>
<p>Quando il codice di un programma deve essere suddiviso in più unità di traduzione, si pone il problema di come fare interagire correttamente le varie porzioni del programma.
Intuitivamente, le varie unità di traduzione devono concordare su una interfaccia comune.
Tale interfaccia è formata quindi da dichiarazioni di tipi, variabili, funzioni, ecc.</p>
<p>Per ridurre il rischio che una delle unità di traduzione si trovi ad operare con una versione diversa (inconsistente) dell'interfaccia, si cerca di seguire la regola <mark style="background: #FFB86CA6;">DRY</mark> ("<u>Don't Repeat Yourself</u>"): le dichiarazioni dell'interfaccia vengono scritte una volta sola, in uno o più header file.</p>
<p>Le varie unità di traduzione includeranno gli header file di cui hanno bisogno, evitando di ripetere le corrispondenti dichiarazioni.
Il meccanismo è intuitivamente semplice, ma se usato senza la necessaria cautela, può dare luogo a problemi che, in ultima analisi, si possono ricondurre a violazioni della "One Definition Rule".</p>
<p>La <strong>ODR</strong> (regola della definizione unica) stabilisce quanto segue:</p>
<ol>
<li>Ogni <u>unità di traduzione</u> che forma un programma può contenere non più di una definizione di una data variabile, funzione, classe, enumerazione o template.</li>
<li>Ogni <u>programma</u> deve contenere esattamente una definizione di ogni variabile e di ogni funzione non-inline usate nel programma.</li>
<li>Ogni <a href="99-definizioni#funzioni%20inline">funzione inline</a> deve essere definita in ogni unità di traduzione che la utilizza.</li>
<li>In un programma vi possono essere più definizioni di una classe, enumerazione, funzione inline, template di classe e template di funzione a condizione che:
<ul>
<li>tali definizioni siano sintatticamente identiche;</li>
<li>tali definizioni siano semanticamente identiche.</li>
</ul>
</li>
</ol>
<p><em><a href="#odr">Torna all'indice</a></em></p>
<hr>
<h2 id="esempi" tabindex="-1"><a class="anchor" href="#esempi" aria-hidden="true"><span class="octicon octicon-link"></span></a> Esempi</h2>
<p>Forniamo alcuni esempi per chiarire i vari punti della ODR; in particolare, ci concentreremo sulle possibili violazioni della regola.</p>
<hr>
<h3 id="violazione-del-punto-1" tabindex="-1"><a class="anchor" href="#violazione-del-punto-1" aria-hidden="true"><span class="octicon octicon-link"></span></a> Violazione del punto 1</h3>
<p>Definizione multipla di tipo in una unità di traduzione:</p>
<pre><code class="language-cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> <span class="hljs-keyword">int</span> a; };
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">double</span> d; };
</code></pre>
<p>Definizione multipla di variabile in una unità di traduzione:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">int</span> a;
<span class="hljs-keyword">int</span> a;
</code></pre>
<p>Il motivo dell'errore è evidente: le due definizioni con lo stesso nome creano una ambiguità.
Si noti che si considera il nome completamente qualificato, per cui la seguente <mark style="background: #BBFABBA6;">NON è una violazione</mark>, perché si tratta di variabili diverse (<code>N::a</code> e <code>::a</code>).</p>
<pre><code class="language-cpp"><span class="hljs-keyword">namespace</span> N { <span class="hljs-keyword">int</span> a; }
<span class="hljs-keyword">int</span> a;
</code></pre>
<p>Analogamente, per le funzioni è lecito l'overloading, per cui anche la seguente <mark style="background: #BBFABBA6;">NON è una violazione</mark>, perché si tratta di funzioni diverse, <code>int ::incr(int)</code> e <code>long ::incr(long)</code>:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">incr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; }
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">incr</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; }
</code></pre>
<p>Si noti inoltre che si parla di definizioni. È lecito avere più dichiarazioni della stessa entità, a condizione che solo una di esse sia una definizione (ovvero, le altre devono essere
dichiarazioni pure).
L'esempio seguente <mark style="background: #BBFABBA6;">NON contiene violazioni</mark> ODR:</p>
<pre><code class="language-cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>;</span>             <span class="hljs-comment">// dichiarazione pura</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> <span class="hljs-keyword">int</span> a; };  <span class="hljs-comment">// definizione</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>;</span>             <span class="hljs-comment">// dichiarazione pura</span>
S a;                  <span class="hljs-comment">// definizione</span>
<span class="hljs-keyword">extern</span> S a;           <span class="hljs-comment">// dichiarazione pura</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;           <span class="hljs-comment">// dichiarazione pura</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{ }        <span class="hljs-comment">// definizione</span>

<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// dichiarazione pura</span>
</code></pre>
<p><em><a href="#odr">Torna all'indice</a></em></p>
<hr>
<h3 id="violazione-del-punto-2" tabindex="-1"><a class="anchor" href="#violazione-del-punto-2" aria-hidden="true"><span class="octicon octicon-link"></span></a> Violazione del punto 2</h3>
<p>Un caso banale è quello dell'uso di una variabile o funzione che è stata dichiarata ma non è stata mai definita nel programma (zero definizioni): la compilazione in senso stretto andrà a buon fine, ma il linker segnalerà l'errore al momento di generare il codice eseguibile.</p>
<p>Più interessante è il caso delle definizioni multiple (magari pure inconsistenti) effettuate in unità di traduzione diverse:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in foo.hh</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;
</code></pre>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in file1.cc</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"foo.hh"</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; }
</code></pre>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in file2.cc</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"foo.hh"</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span>; }
</code></pre>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in file3.cc</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"foo.hh"</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">foo</span>(a); }
</code></pre>
<p>Il linker, al momento di collegare (l'object file prodotto dalla compilazione di) <code>file3.cc</code> con il resto del programma potrebbe indifferentemente invocare la funzione foo definita in <code>file1.cc</code> o quella definita in <code>file2.cc</code>, ottenendo effetti non prevedibili.</p>
<p>Tipicamente, il linker segnalerà l'errore, ma in realtà le regole del linguaggio dicono che non è tenuto a farlo (la formula usata nello standard è <mark style="background: #FF5582A6;">"no diagnostic required"</mark>) e, nel caso, la colpa dell'errore ricade sul programmatore.</p>
<p><em><a href="#odr">Torna all'indice</a></em></p>
<hr>
<h3 id="violazione-del-punto-3" tabindex="-1"><a class="anchor" href="#violazione-del-punto-3" aria-hidden="true"><span class="octicon octicon-link"></span></a> Violazione del punto 3</h3>
<p>Il punto 3 dice che le funzioni inline devono essere definite ovunque sono usate; il senso della regola è chiaro, se si è compreso il meccanismo dell'<a href="99-definizioni#funzioni%20inline">inlining delle funzioni</a>, che prevede che la chiamata di funzione possa essere sostituita con l'espansione in linea del corpo della funzione (a scopo di ottimizzazione).
Tale espansione è effettuata durante la fase di compilazione in senso stretto, per cui il corpo della funzione deve essere presente in ogni unità di traduzione che contiene una chiamata.</p>
<blockquote>
<p>Per quanto detto, il linker deve segnalare come errore il caso di una funzione non-inline che è definita in più unità di traduzione, mentre non deve segnalare errore se la funzione è inline.
Come fa a distinguere questi due casi? La risposta la possiamo intuire usando lo strumento <code>nm</code> che visualizza il contenuto di un object file.</p>
</blockquote>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in aaa.cc</span>

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">funzione_inline</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">funzione_non_inline</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">funzione_inline</span>(); }
</code></pre>
<p>Compilando con l'opzione <code>-C</code> e invocando <code>nm</code> sull'object file generato, vediamo quanto segue:</p>
<pre><code class="language-bash">$ nm -C aaa.o
0000000000000000 W funzione_inline()
0000000000000000 T funzione_non_inline()
</code></pre>
<p>La funzione non inline è marcata come simbolo definito (etichetta <code>T</code>).
La funzione inline, invece, è marcata con l'etichetta <code>W</code> (weak symbol).
Dal manuale di <code>nm</code>:</p>
<pre><code class="language-bash"><span class="hljs-string">"W"</span>
<span class="hljs-string">"w"</span> The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.  
When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error.  
When a weak undefined symbol is linked and the symbol is not defined, the value of the symbol is determined <span class="hljs-keyword">in</span> a system-specific manner without error.  
On some systems, uppercase indicates that a default value has been specified.
</code></pre>
<p><em><a href="#odr">Torna all'indice</a></em></p>
<hr>
<h3 id="violazione-del-punto-4" tabindex="-1"><a class="anchor" href="#violazione-del-punto-4" aria-hidden="true"><span class="octicon octicon-link"></span></a> Violazione del punto 4</h3>
<p>Il punto più interessante della ODR è il 4. Si applica a classi, enumerazioni, funzione inline, template di classe e template di funzione, ma per comprendere il problema è sufficiente considerare il caso delle definizioni di classi.</p>
<h4 id="esempio-di-violazione-della-4a" tabindex="-1"><a class="anchor" href="#esempio-di-violazione-della-4a" aria-hidden="true"><span class="octicon octicon-link"></span></a> Esempio di violazione della 4a</h4>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in file1.cc</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> 
	<span class="hljs-keyword">int</span> a; 
	<span class="hljs-keyword">int</span> b; 
};			 <span class="hljs-comment">// definizione del tipo S</span>
S s;         <span class="hljs-comment">// definizione di variabile di tipo S</span>
</code></pre>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in file2.cc</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> <span class="hljs-keyword">int</span> b; <span class="hljs-keyword">int</span> a; }; <span class="hljs-comment">// definizione del tipo S (sintassi diversa)</span>
<span class="hljs-keyword">extern</span> S s;  <span class="hljs-comment">// dichiarazione pura della s definita in file1.cc</span>
</code></pre>
<p>Quando il compilatore lavora su <code>file2.cc</code>, viene ingannato dalla diversa definizione del tipo <code>S</code>, ma non se ne può accorgere. Non è nemmeno detto che se ne accorga il linker (in ogni caso, non è tenuto a farlo).</p>
<p>Con una piccola variante, è possibile ottenere una violazione della 4b, nella quale i tipi sono sintatticamente identici, ma semanticamente diversi:</p>
<h4 id="esempio-di-violazione-della-4b" tabindex="-1"><a class="anchor" href="#esempio-di-violazione-della-4b" aria-hidden="true"><span class="octicon octicon-link"></span></a> Esempio di violazione della 4b</h4>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in file1.cc</span>

<span class="hljs-keyword">typedef</span> T <span class="hljs-keyword">int</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> T a; T b; }; <span class="hljs-comment">// definizione del tipo S</span>
</code></pre>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in file2.cc</span>

<span class="hljs-keyword">typedef</span> T <span class="hljs-keyword">double</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> 
	T a; 
	T b; 
};       <span class="hljs-comment">// definizione del tipo S</span>
         <span class="hljs-comment">// (sintassi identica, ma semantica diversa)</span>
</code></pre>
<p><em><a href="#odr">Torna all'indice</a></em></p>
<hr>
<h2 id="il-tipo-razionale" tabindex="-1"><a class="anchor" href="#il-tipo-razionale" aria-hidden="true"><span class="octicon octicon-link"></span></a> Il tipo Razionale</h2>
<p>Avendo analizzato le clausole che compongono la ODR, rimane da capire cosa va fatto all'atto pratico per garantirne la soddisfazione.</p>
<p>La linea guida principale, già nominata, è la DRY (don't repeat yourself), a volte detta anche <em>"write once"</em>: scrivere una volta sola le dichiarazioni e/o definizioni, inserendole negli header file, e includere questi dove necessario.</p>
<p>L'esempio seguente mostra che l'approccio non risolve tutti i problemi.</p>
<p>Supponiamo di avere un programma che effettua calcoli matematici. Il programma necessita di utilizzare numeri razionali, per i quali si crea un tipo apposito (<code>Razionale</code>), la cui definizione è messa nell'header file <code>Razionale.hh</code>:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in Razionale.hh</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Razionale</span> {</span>
  <span class="hljs-comment">// ... le cose giuste</span>
};
</code></pre>
<p>Una seconda parte del programma deve gestire polinomi a coefficienti razionali, per cui si crea un altro header file:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in Polinomio.hh</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Razionale.hh"</span></span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polinomio</span> {</span>
	 <span class="hljs-comment">// ... le cose giuste, usando anche Razionale</span>
};
</code></pre>
<p>In una terza parte del programma, si deve scrivere un algoritmo che effettua calcoli sui polinomi, usando anche i razionali:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in Calcolo.cc</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Razionale.hh"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Polinomio.hh"</span></span>

<span class="hljs-comment">// Codice che usa i tipi Polinomio e Razionale</span>
</code></pre>
<p>Quando compileremo (l'unità di traduzione corrispondente a) <code>Calcolo.cc</code>, otterremo un errore dovuto alla violazione della clausola 1 della ODR.
L'unità conterrà infatti <em>due</em> definizioni della classe <code>Razionale</code>, la prima ottenuta dalla prima direttiva di inclusione e la seconda ottenuta (indirettamente) dalla seconda direttiva di inclusione.</p>
<p><em><a href="#odr">Torna all'indice</a></em></p>
<hr>
<h3 id="qual-%C3%A8-il-modo-corretto-di-risolvere-questa-situazione" tabindex="-1"><a class="anchor" href="#qual-%C3%A8-il-modo-corretto-di-risolvere-questa-situazione" aria-hidden="true"><span class="octicon octicon-link"></span></a> Qual è il modo corretto di risolvere questa situazione?</h3>
<p>Un modo sicuramente <mark style="background: #FF5582A6;">sbagliato</mark> (dal punto di vista metodologico) è quello di modificare <code>Calcolo.cc</code>, eliminando l'inclusione di <code>Razionale.hh</code>:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in Calcolo.cc</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Polinomio.hh"</span></span>

<span class="hljs-comment">// Codice che usa i tipi Polinomio e Razionale</span>
</code></pre>
<p>Questo approccio <em>sembra</em> funzionare nella situazione contingente, ma è destinato a creare più problemi di quanti non ne risolva.</p>
<p>In primo luogo, diminuisce la leggibilità del codice, perché non è più così evidente che <code>Calcolo.cc</code> dipende anche dall'header file <code>Razionale.hh</code> (affidandosi all'inclusione indiretta).</p>
<p>In secondo luogo, occorre considerare cosa succede se il responsabile dello sviluppo della classe <code>Polinomio</code> decidesse di modificare l'implementazione della sua classe, per esempio per utilizzare il tipo di dato <code>Frazione</code> al posto di <code>Razionale</code> (eliminando l'inclusione di questo header file): la compilazione di <code>Calcolo.cc</code> fallirebbe anche se nessuno ne ha modificato il file sorgente (cosa che non accadrebbe se venisse mantenuta in <code>Calcolo.cc</code> l'inclusione di <code>Razionale.hh</code>).</p>
<p><mark style="background: #FFB86CA6;">Occorre quindi consentire ad ogni unità di traduzione di includere tutti gli header file di cui necessita</mark>, trovando una soluzione alternativa al problema delle inclusioni multiple dello stesso header file.</p>
<p>Alcuni compilatori prevedono l'utilizzo di direttive speciali per il processore (che non sono standard), come <code>#pragma once</code> che, inserita nell'header file, comunica al preprocessore di evitarne l'inclusione multipla.</p>
<p>Una soluzione che invece è garantita funzionare per qualunque compilatore si basa sull'uso delle <mark style="background: #BBFABBA6;">"guardie contro l'inclusione ripetuta"</mark>.
In pratica, l'header file <code>Razionale.hh</code> viene modificato in questo modo:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// Siamo in Razionale.hh</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> RAZIONALE_HH_INCLUDE_GUARD</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAZIONALE_HH_INCLUDE_GUARD 1</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Razionale</span> {</span>
  <span class="hljs-comment">// ... le cose giuste</span>
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* RAZIONALE_HH_INCLUDE_GUARD */</span></span>
</code></pre>
<p><mark style="background: #ABF7F7A6;">La prima volta che il file viene incluso, la <i>"guardia"</i></mark> (ovvero, il flag del preprocessore <code>RAZIONALE_HH_INCLUDE_GUARD</code>) <mark style="background: #ABF7F7A6;">NON è ancora definita e quindi il preprocessore procede con l'inclusione.</mark>
Come prima cosa, viene definita la guardia stessa e poi si includono nell'unità di traduzione tutte le dichiarazioni e definizioni (potenzialmente elaborando altre direttive di inclusione).
Se capitasse, durante il preprocessing di quella stessa unità di traduzione, di ritentare altre volte l'inclusione di <code>Razionale.hh</code>, il preprocessore troverebbe la guardia già definita; la condizione di <code>#ifndef</code> valuterebbe a falso e quindi non avverrebbe nessuna inclusione ripetuta.</p>
<blockquote>
<p><mark style="background: #FF5582A6;">NOTA:</mark> questa soluzione, per funzionare, deve essere applicata sistematicamente su <em>tutti</em> gli header file che fanno parte del programma (<code>Polinomio.hh</code>, ecc).
Inoltre, occorre prestare attenzione ed evitare di usare la stessa guardia (ovvero, flag del preprocessore con lo stesso nome) per file di inclusione distinti.</p>
</blockquote>
<blockquote>
<p><mark style="background: #FF5582A6;">NOTA:</mark> verificare che le guardie contro l'inclusione ripetuta sono utilizzate negli header file della libreria standard distribuiti con <code>g++</code>.</p>
</blockquote>
<p>Per esempio, nell'header file <code>iostream</code>:</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _GLIBCXX_IOSTREAM</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GLIBCXX_IOSTREAM 1</span>

<span class="hljs-comment">// ...</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* _GLIBCXX_IOSTREAM */</span></span>
</code></pre>
<p><em><a href="#odr">Torna all'indice</a></em></p>
<hr>
<h2 id="costrutti-del-linguaggio" tabindex="-1"><a class="anchor" href="#costrutti-del-linguaggio" aria-hidden="true"><span class="octicon octicon-link"></span></a> Costrutti del linguaggio</h2>
<p>Dopo avere discusso della ODR e delle sue possibili violazioni, può essere utile fare un <mark style="background: #BBFABBA6;">elenco dei costrutti del linguaggio che è ragionevole trovare all'interno di un header file:</mark></p>
<ul>
<li>direttive del preprocessore (inclusione, guardie, macro, ...)</li>
<li>commenti</li>
<li>dichiarazioni o definizioni di tipo</li>
<li>dichiarazioni di variabili</li>
<li>definizioni di costanti</li>
<li>dichiarazioni di funzioni</li>
<li>definizioni di funzioni inline</li>
<li>dichiarazioni o definizioni di template</li>
<li>namespace dotati di nome: <code>namespace N { ... }</code></li>
<li>alias di tipi: <code>{ typedef std::vector&lt;int&gt; Ints; using Ints = std::vector&lt;int&gt;; }</code></li>
</ul>
<p><mark style="background: #FF5582A6;"><u>I seguenti costrutti, invece, NON si dovrebbero trovare in un header file:</u></mark></p>
<ul>
<li>definizione di variabili</li>
<li>definizione di funzioni</li>
</ul>
<h3 id="perch%C3%A8" tabindex="-1"><a class="anchor" href="#perch%C3%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a> Perchè?</h3>
<p>Siccome gli header file sono pensati per essere inclusi in più unità di traduzione, si avrebbe una violazione della ODR (clausola 2).</p>
<p><mark style="background: #FF5582A6;">Anche i seguenti costrutti NON si dovrebbero trovare in un header file:</mark></p>
<ul>
<li>namespace anonimi: <code>namespace { ... }</code></li>
<li>dichiarazioni di <code>using</code></li>
<li>direttive di <code>using</code></li>
</ul>
<p>In questo caso, però, non c'entra la <em>ODR</em>. Direttive e dichiarazioni di <code>using</code> annullano il meccanismo di protezione dai conflitti di nomi che viene fornito dai <code>namespace</code>.</p>
<p><mark style="background: #ABF7F7A6;">È lecito</mark> farlo in contesti molto limitati e sotto il nostro controllo (ad esempio, all'interno della definizione di una funzione o all'interno di una unica unità di traduzione).
<mark style="background: #FFB8EBA6;">È considerato cattivo stile</mark> invece farlo in un <code>header file</code> (a meno che non si sia all'interno del corpo di una funzione inline o di un template di funzione), perché il potenziale problema si propagherebbe a tutte le unità di traduzione che includono il nostro <code>header file</code> (direttamente o indirettamente).</p>
<p><em><a href="#odr">Torna all'indice</a></em></p>

		</main>
	</body>
</html>
