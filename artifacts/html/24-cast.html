<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
		<title>24-cast</title>
		<style>
			/* PDF Specific */

@media print {
  body {
    min-width: initial;
    max-width: 100%;
    margin: 0 auto;
  }
}

/* General */

.octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.anchor:focus {
  outline: none;
}

h1 .octicon-link,
h2 .octicon-link,
h3 .octicon-link,
h4 .octicon-link,
h5 .octicon-link,
h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
  text-decoration: none;
}

h1:hover .anchor .octicon-link,
h2:hover .anchor .octicon-link,
h3:hover .anchor .octicon-link,
h4:hover .anchor .octicon-link,
h5:hover .anchor .octicon-link,
h6:hover .anchor .octicon-link {
  visibility: visible;
}

h1:hover .anchor .octicon-link:before,
h2:hover .anchor .octicon-link:before,
h3:hover .anchor .octicon-link:before,
h4:hover .anchor .octicon-link:before,
h5:hover .anchor .octicon-link:before,
h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' width='16' height='16' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z'%3E%3C/path%3E%3C/svg%3E");
}

body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  -webkit-print-color-adjust: exact;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial,
    sans-serif, Apple Color Emoji, Segoe UI Emoji;
  font-size: 16px;
  line-height: 1.5;
  color: #24292e;
  word-wrap: break-word;
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 1rem auto;
}

details {
  display: block;
}

summary {
  display: list-item;
}

a {
  background-color: initial;
}

a:active,
a:hover {
  outline-width: 0;
}

strong {
  font-weight: inherit;
  font-weight: bolder;
}

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

img {
  border-style: none;
}

code,
kbd,
pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

hr {
  box-sizing: initial;
  height: 0;
  overflow: visible;
}

input {
  font: inherit;
  margin: 0;
}

input {
  overflow: visible;
}

[type='checkbox'] {
  box-sizing: border-box;
  padding: 0;
}

* {
  box-sizing: border-box;
}

input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

strong {
  font-weight: 600;
}

hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}

hr:after,
hr:before {
  display: table;
  content: '';
}

hr:after {
  clear: both;
}

table {
  border-spacing: 0;
  border-collapse: collapse;
}

td,
th {
  padding: 0;
}

details summary {
  cursor: pointer;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 0;
  margin-bottom: 0;
}

h1 {
  font-size: 32px;
}

h1,
h2 {
  font-weight: 600;
}

h2 {
  font-size: 24px;
}

h3 {
  font-size: 20px;
}

h3,
h4 {
  font-weight: 600;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h5,
h6 {
  font-weight: 600;
}

h6 {
  font-size: 12px;
}

p {
  margin-top: 0;
  margin-bottom: 10px;
}

blockquote {
  margin: 0;
}

ol,
ul {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

ol ol,
ul ol {
  list-style-type: lower-roman;
}

ol ol ol,
ol ul ol,
ul ol ol,
ul ul ol {
  list-style-type: lower-alpha;
}

dd {
  margin-left: 0;
}

code,
pre {
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
}

pre {
  margin-top: 0;
  margin-bottom: 0;
}

input::-webkit-inner-spin-button,
input::-webkit-outer-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

:checked + .radio-label {
  position: relative;
  z-index: 1;
  border-color: #0366d6;
}

.border {
  border: 1px solid #e1e4e8 !important;
}

.border-0 {
  border: 0 !important;
}

.border-bottom {
  border-bottom: 1px solid #e1e4e8 !important;
}

.rounded-1 {
  border-radius: 3px !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-gray-light {
  background-color: #fafbfc !important;
}

.text-gray-light {
  color: #6a737d !important;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-top: 8px !important;
  margin-bottom: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3,
.px-3 {
  padding-left: 16px !important;
}

.px-3 {
  padding-right: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.f6 {
  font-size: 12px !important;
}

.lh-condensed {
  line-height: 1.25 !important;
}

.text-bold {
  font-weight: 600 !important;
}

.pl-c {
  color: #6a737d;
}

.pl-c1,
.pl-s .pl-v {
  color: #005cc5;
}

.pl-e,
.pl-en {
  color: #6f42c1;
}

.pl-s .pl-s1,
.pl-smi {
  color: #24292e;
}

.pl-ent {
  color: #22863a;
}

.pl-k {
  color: #d73a49;
}

.pl-pds,
.pl-s,
.pl-s .pl-pse .pl-s1,
.pl-sr,
.pl-sr .pl-cce,
.pl-sr .pl-sra,
.pl-sr .pl-sre {
  color: #032f62;
}

.pl-smw,
.pl-v {
  color: #e36209;
}

.pl-bu {
  color: #b31d28;
}

.pl-ii {
  color: #fafbfc;
  background-color: #b31d28;
}

.pl-c2 {
  color: #fafbfc;
  background-color: #d73a49;
}

.pl-c2:before {
  content: '^M';
}

.pl-sr .pl-cce {
  font-weight: 700;
  color: #22863a;
}

.pl-ml {
  color: #735c0f;
}

.pl-mh,
.pl-mh .pl-en,
.pl-ms {
  font-weight: 700;
  color: #005cc5;
}

.pl-mi {
  font-style: italic;
  color: #24292e;
}

.pl-mb {
  font-weight: 700;
  color: #24292e;
}

.pl-md {
  color: #b31d28;
  background-color: #ffeef0;
}

.pl-mi1 {
  color: #22863a;
  background-color: #f0fff4;
}

.pl-mc {
  color: #e36209;
  background-color: #ffebda;
}

.pl-mi2 {
  color: #f6f8fa;
  background-color: #005cc5;
}

.pl-mdr {
  font-weight: 700;
  color: #6f42c1;
}

.pl-ba {
  color: #586069;
}

.pl-sg {
  color: #959da5;
}

.pl-corl {
  text-decoration: underline;
  color: #032f62;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-bottom: 8px !important;
}

.my-2 {
  margin-top: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3 {
  padding-left: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.pl-7 {
  padding-left: 48px !important;
}

.pl-8 {
  padding-left: 64px !important;
}

.pl-9 {
  padding-left: 80px !important;
}

.pl-10 {
  padding-left: 96px !important;
}

.pl-11 {
  padding-left: 112px !important;
}

.pl-12 {
  padding-left: 128px !important;
}

hr {
  border-bottom-color: #eee;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

body:after,
body:before {
  display: table;
  content: '';
}

body:after {
  clear: both;
}

body > :first-child {
  margin-top: 0 !important;
}

body > :last-child {
  margin-bottom: 0 !important;
}

a:not([href]) {
  color: inherit;
  text-decoration: none;
}

blockquote,
details,
dl,
ol,
p,
pre,
table,
ul {
  margin-top: 0;
  margin-bottom: 16px;
}

hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}

blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
}

blockquote > :first-child {
  margin-top: 0;
}

blockquote > :last-child {
  margin-bottom: 0;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h1 {
  font-size: 2em;
}

h1,
h2 {
  padding-bottom: 0.3em;
  border-bottom: 1px solid #eaecef;
}

h2 {
  font-size: 1.5em;
}

h3 {
  font-size: 1.25em;
}

h4 {
  font-size: 1em;
}

h5 {
  font-size: 0.875em;
}

h6 {
  font-size: 0.85em;
  color: #6a737d;
}

ol,
ul {
  padding-left: 2em;
}

ol ol,
ol ul,
ul ol,
ul ul {
  margin-top: 0;
  margin-bottom: 0;
}

li {
  word-wrap: break-all;
}

li > p {
  margin-top: 16px;
}

li + li {
  margin-top: 0.25em;
}

dl {
  padding: 0;
}

dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

table {
  display: block;
  width: 100%;
  overflow: auto;
}

table th {
  font-weight: 600;
}

table td,
table th {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

img {
  max-width: 80%;
  box-sizing: initial;
  display: block;
  margin-left: auto;
  margin-right: auto;
  background-color: #fff;
}

code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27, 31, 35, 0.05);
  border-radius: 3px;
}

pre {
  word-wrap: normal;
}

pre > code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  -webkit-print-color-adjust: exact;
  background: #f8f8f8;
}

.hljs pre {
  margin-bottom: 0;
  word-break: normal;
}

.hljs pre,
pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  -webkit-print-color-adjust: exact;

  border-radius: 3px;
}

pre code {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: initial;
  border: 0;
}

.commit-tease-sha {
  display: inline-block;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 90%;
  color: #444d56;
}

.full-commit .btn-outline:not(:disabled):hover {
  color: #005cc5;
  border-color: #005cc5;
}

.blob-wrapper {
  overflow-x: auto;
  overflow-y: hidden;
}

.blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.blob-num {
  width: 1%;
  min-width: 50px;
  padding-right: 10px;
  padding-left: 10px;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  line-height: 20px;
  color: rgba(27, 31, 35, 0.3);
  text-align: right;
  white-space: nowrap;
  vertical-align: top;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.blob-num:hover {
  color: rgba(27, 31, 35, 0.6);
}

.blob-num:before {
  content: attr(data-line-number);
}

.blob-code {
  position: relative;
  padding-right: 10px;
  padding-left: 10px;
  line-height: 20px;
  vertical-align: top;
}

.blob-code-inner {
  overflow: visible;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  color: #24292e;
  word-wrap: normal;
  white-space: pre;
}

.pl-token.active,
.pl-token:hover {
  cursor: pointer;
  background: #ffea7f;
}

.tab-size[data-tab-size='1'] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.tab-size[data-tab-size='2'] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.tab-size[data-tab-size='3'] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.tab-size[data-tab-size='4'] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.tab-size[data-tab-size='5'] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.tab-size[data-tab-size='6'] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.tab-size[data-tab-size='7'] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.tab-size[data-tab-size='8'] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.tab-size[data-tab-size='9'] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.tab-size[data-tab-size='10'] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.tab-size[data-tab-size='11'] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.tab-size[data-tab-size='12'] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.task-list-item {
  list-style-type: none;
}

.task-list-item + .task-list-item {
  margin-top: 3px;
}

.task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}
/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/
  
  .hljs-comment,
  .hljs-quote {
    color: #998;
    font-style: italic;
  }
  
  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-subst {
    color: #333;
    font-weight: bold;
  }
  
  .hljs-number,
  .hljs-literal,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-tag .hljs-attr {
    color: #008080;
  }
  
  .hljs-string,
  .hljs-doctag {
    color: #d14;
  }
  
  .hljs-title,
  .hljs-section,
  .hljs-selector-id {
    color: #900;
    font-weight: bold;
  }
  
  .hljs-subst {
    font-weight: normal;
  }
  
  .hljs-type,
  .hljs-class .hljs-title {
    color: #458;
    font-weight: bold;
  }
  
  .hljs-tag,
  .hljs-name,
  .hljs-attribute {
    color: #000080;
    font-weight: normal;
  }
  
  .hljs-regexp,
  .hljs-link {
    color: #009926;
  }
  
  .hljs-symbol,
  .hljs-bullet {
    color: #990073;
  }
  
  .hljs-built_in,
  .hljs-builtin-name {
    color: #0086b3;
  }
  
  .hljs-meta {
    color: #999;
    font-weight: bold;
  }
  
  .hljs-deletion {
    background: #fdd;
  }
  
  .hljs-addition {
    background: #dfd;
  }
  
  .hljs-emphasis {
    font-style: italic;
  }
  
  .hljs-strong {
    font-weight: bold;
  }
		</style>
<script> MathJax = { tex: { inlineMath: [["$", "$"]] } }; </script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
	</head>
	<body>
		<nav id="table-of-contents">
			<ul><li><a href="#cast"> Cast</a><ul><li><a href="#conversioni-esplicite-di-tipo-in-c"> Conversioni esplicite di tipo in C++</a></li><li><a href="#classificazione-delle-motivazioni-per-luso-di-cast-espliciti"> Classificazione delle motivazioni per l'uso di cast espliciti</a></li><li><a href="#tipologie-di-cast"> Tipologie di cast</a><ul><li><a href="#staticcast"> static_cast</a></li><li><a href="#dynamiccast"> dynamic_cast</a></li><li><a href="#constcast"> const_cast</a></li><li><a href="#reinterpretcast"> reinterpret_cast</a></li><li><a href="#cast-funzionale"> cast funzionale</a></li><li><a href="#cast-stile-c"> cast stile C</a></li></ul></li></ul></li></ul>
		</nav>
		<main>
			<h1 id="cast" tabindex="-1"><a class="anchor" href="#cast" aria-hidden="true"><span class="octicon octicon-link"></span></a> Cast</h1>
<pre><code class="language-toc"></code></pre>
<hr>
<h2 id="conversioni-esplicite-di-tipo-in-c" tabindex="-1"><a class="anchor" href="#conversioni-esplicite-di-tipo-in-c" aria-hidden="true"><span class="octicon octicon-link"></span></a> Conversioni esplicite di tipo in C++</h2>
<p>Il $C$++ fornisce varie sintassi per effettuare il cast (conversione esplicita di tipo) di una espressione, allo scopo di ottenere un valore di un tipo (potenzialmente) diverso:</p>
<ol>
<li><code>static_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li>cast "funzionale"</li>
<li>cast stile $C$</li>
</ol>
<p>Prima di considerare nel dettaglio le varie sintassi dei cast, vale la pena ragionare sui motivi (validi) per il loro uso.</p>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="classificazione-delle-motivazioni-per-luso-di-cast-espliciti" tabindex="-1"><a class="anchor" href="#classificazione-delle-motivazioni-per-luso-di-cast-espliciti" aria-hidden="true"><span class="octicon octicon-link"></span></a> Classificazione delle motivazioni per l'uso di cast espliciti</h2>
<p>Essendo conversioni esplicite di tipo, i cast dovrebbero essere utilizzati solo quando necessario. E' possibile classificare gli usi dei cast in base alla motivazione, che frequentemente ricade in una di queste categorie:</p>
<ol>
<li>Il cast implementa una conversione di tipo che NON è consentita dalle regole del linguaggio come conversione implicita, in quanto considerata una frequente fonte di errori di programmazione. Il programmatore, richiedendo esplicitamente la conversione con il cast, si assume la responsabilità della sua correttezza.
Esempio:</li>
</ol>
<pre><code class="language-cpp">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> {</span> <span class="hljs-comment">/* ... */</span> };
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B { <span class="hljs-comment">/* ... */</span> };
	D d;
	B* b_ptr = &amp;d;
	<span class="hljs-comment">// b_ptr è (staticamente, cioè a tempo di compilazione) un puntatore a B,</span>
	<span class="hljs-comment">// ma (dinamicamente, cioè a tempo di esecuzione) sta puntando ad un</span>
	<span class="hljs-comment">// oggetto di tipo D.</span>
	<span class="hljs-comment">/* ... altro codice ... */</span>
	<span class="hljs-comment">// Il programmatore forza il down-cast, prendendosi la responsabilità</span>
	<span class="hljs-comment">// di eventuali errori: se qualcuno nel frattempo avesse modificato b_ptr</span>
	<span class="hljs-comment">// e questo non puntasse più ad un oggetto di tipo D, si ottiene un</span>
	<span class="hljs-comment">// Undefined Behavior.</span>
	D* d_ptr = <span class="hljs-keyword">static_cast</span>&lt;D*&gt;(b_ptr);
</code></pre>
<ol start="2">
<li>Come nel caso precedente, ma il programmatore usa (in modo appropriato) un <code>dynamic_cast</code> allo scopo di controllare, a tempo di esecuzione, se la conversione richiesta è effettivamente consentita.
Esempio:</li>
</ol>
<pre><code class="language-cpp">	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> {</span> <span class="hljs-comment">/* ... */</span> };
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B { <span class="hljs-comment">/* ... */</span> };
	
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(B* b_ptr)</span> </span>{
		<span class="hljs-keyword">if</span> (D* d_ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;D*&gt;(b_ptr)) {
			<span class="hljs-comment">// posso usare d_ptr, che punta ad un oggetto di tipo D</span>
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">// qui so che b_ptr NON sta puntando ad un oggetto di tipo D</span>
		}
	}
</code></pre>
<ol start="3">
<li>Il cast NON è strettamente necessario (in quanto la corrispondente conversione implicita è consentita dal linguaggio), ma il programmatore preferisce comunque la forma esplicita a scopo di documentazione, per tenere una traccia esplicita della conversione di tipo effettuata e migliorare la leggibilità del codice.
In altre parole, il programmatore ritiene che il cast sia necessario dal punto di vista metodologico (anche se non lo è dal punto di vista tecnico).
Esempio:</li>
</ol>
<pre><code class="language-cpp">	<span class="hljs-keyword">double</span> d = <span class="hljs-comment">/* .... */</span>;
	<span class="hljs-comment">// La conversione implicita double-&gt;int è ammessa, ma usando il cast</span>
	<span class="hljs-comment">// il programmatore vuole probabilmente attirare l'attenzione sul</span>
	<span class="hljs-comment">// fatto che passando da un tipo floating point ad un tipo intero</span>
	<span class="hljs-comment">// tipicamente si perde informazione.</span>
	<span class="hljs-keyword">int</span> approx = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(d);
</code></pre>
<ol start="4">
<li>Un caso speciale di uso (qualcuno potrebbe pure dire "abuso") di un cast esplicito riguarda la conversione di una espressione al tipo void (che non ha valori), che intuitivamente corrisponde ad una richiesta di "scartare" o "ignorare" il valore dell'espressione.
Per convenzione, il cast a void si può usare per silenziare alcune segnalazioni di warning fornite dal compilatore (questa convenzione è rispettata sia da g++ che da clang++).
Esempio:</li>
</ol>
<pre><code class="language-cpp">	<span class="hljs-comment">// Il parametro size lo si usa solo nella assert e quindi, quando le</span>
	<span class="hljs-comment">// asserzioni NON sono attivate, il compilatore mi segnalerebbe</span>
	<span class="hljs-comment">// il suo mancato uso mediante un warning;</span>
	<span class="hljs-comment">// il cast esplicito serve a silenziare questo warning.</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> size)</span> </span>{
		<span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= pos &amp;&amp; pos &lt; size);
		<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>&gt;(size);
		<span class="hljs-comment">/* ... codice che non usa size ... */</span>
	}
</code></pre>
<blockquote>
<p>In questo caso spesso si usa, per convenzione, un cast stile $C$: <code>(void) size</code>.
In realtà, questo è l'unico caso in cui l'uso di un cast stile $C$ (in $C$++) è tollerato: ogni altro uso è considerato (giustamente) cattivo stile.</p>
</blockquote>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="tipologie-di-cast" tabindex="-1"><a class="anchor" href="#tipologie-di-cast" aria-hidden="true"><span class="octicon octicon-link"></span></a> Tipologie di cast</h2>
<p>Descriviamo ora brevemente le diverse tipologie di cast:</p>
<ul>
<li>[[#static_cast]]</li>
<li>[[#dynamic_cast]]</li>
<li>[[#const_cast]]</li>
<li>[[#reinterpret_cast]]</li>
<li>[[#cast funzionale]]</li>
<li>[[#cast stile C]]</li>
</ul>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="staticcast" tabindex="-1"><a class="anchor" href="#staticcast" aria-hidden="true"><span class="octicon octicon-link"></span></a> static_cast</h3>
<p>Probabilmente, è il cast utilizzato più frequentemente. La sintassi</p>
<pre><code class="language-cpp"><span class="hljs-keyword">static_cast</span>&lt;T&gt;(expr)
</code></pre>
<p>calcola un nuovo valore ottenuto dalla conversione del valore dell'espressione <code>expr</code> al tipo <code>T</code>.
Il cast è legittimo in uno dei casi seguenti (elenco parziale, non esaustivo):</p>
<ul>
<li>è legittima la corrispondente conversione implicita (caso banale);</li>
</ul>
<pre><code class="language-cpp">     <span class="hljs-keyword">double</span> d = <span class="hljs-number">3.14</span>;
     <span class="hljs-keyword">int</span> approx = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(d);
</code></pre>
<ul>
<li>è legittima la costruzione diretta di un oggetto di tipo T passando expr come argomento;</li>
</ul>
<pre><code class="language-cpp">     Razionale r = <span class="hljs-keyword">static_cast</span>&lt;Razionale&gt;(<span class="hljs-number">5</span>);
</code></pre>
<ul>
<li>si effettua la conversione inversa rispetto ad un sequenza di conversione implicita ammissibile (con alcune restrizioni, per esempio non si possono invertire le trasformazioni di lvalue);</li>
</ul>
<pre><code class="language-cpp">     <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
     <span class="hljs-keyword">void</span>* v_ptr = &amp;i;
     <span class="hljs-keyword">int</span>* i_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(v_ptr);
</code></pre>
<ul>
<li>il cast implementa un downcast in una gerarchia di classi;</li>
<li>il cast implementa un cast da un tipo numerico ad un tipo enumerazione;</li>
<li>il tipo destinazione è void.</li>
</ul>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="dynamiccast" tabindex="-1"><a class="anchor" href="#dynamiccast" aria-hidden="true"><span class="octicon octicon-link"></span></a> dynamic_cast</h3>
<p>Il dynamic_cast è uno degli operatori che forniscono il supporto per la cosiddetta <em>RTTI</em> (<u>Run-Time Type Identification</u>, cioè identificazione del tipo a tempo di esecuzione). I dynamic cast possono essere usati per effettuare conversioni all'interno di una gerarchia di classi legate da ereditarietà (singola o multipla). In particolare, si possono effettuare:</p>
<ul>
<li>
<p><mark style="background: #BBFABBA6;">up-cast:</mark> conversione da classe derivata a classe base; effettuata raramente mediante dynamic_cast, in quanto è una conversione consentita anche implicitamente e quindi non necessita della RTTI.</p>
</li>
<li>
<p><mark style="background: #BBFABBA6;">down-cast:</mark> conversione da classe base a classe derivata; è il caso più frequente di utilizzo del dynamic cast, in quanto si sfrutta la RTTI per verificare che la conversione sia legittima.</p>
</li>
<li>
<p><mark style="background: #BBFABBA6;">mixed-cast:</mark> caso particolare che si verifica quando si utilizza l'ereditarietà multipla; consiste in uno spostamento nella gerarchia di ereditarietà ottenibile combinando up-cast e down-cast (da cui il nome di cast "misto"); siccome prevede comunque la presenza di down-cast, anche in questo caso si ha un uso non banale della RTTI.</p>
</li>
</ul>
<p>Il dynamic cast si può applicare ai tipi puntatore (caso tipico) e anche ai tipi riferimento (caso raro), con una importante differenza semantica.</p>
<p>Supponiamo di avere la seguente gerarchia:</p>
<pre><code class="language-cpp">   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> {</span> <span class="hljs-comment">/* ... */</span> };
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D1</span> :</span> <span class="hljs-keyword">public</span> B { <span class="hljs-comment">/* ... */</span> };
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D2</span> :</span> <span class="hljs-keyword">public</span> B { <span class="hljs-comment">/* ... */</span> };
</code></pre>
<p>e di avere la funzione</p>
<pre><code class="language-cpp">   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(B* b_ptr)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre>
<p>Se la classe B è dinamica (ovvero, se contiene almeno un metodo virtuale) allora è dotata delle informazioni per la <em>RTTI</em> e possiamo applicare cast dinamici ai puntatori per sapere se sono di un determinato tipo.
Per esempio:</p>
<pre><code class="language-cpp">	D1* d1_ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;D1*&gt;(b_ptr)
</code></pre>
<p>Dopo l'esecuzione di questo cast, se il puntatore <code>b_ptr</code> punta ad un oggetto di tipo <code>D1</code> (incluso eventualmente un oggetto di una classe derivata, anche indirettamente, da <code>D1</code>), allora <code>d1_ptr</code> avrà assegnato un valore NON nullo.
Se invece <code>b_ptr</code> non punta ad un oggetto di tipo <code>D1</code> (per esempio, punta ad un oggetto di tipo <code>D2</code>), allora a <code>d1_ptr</code> viene assegnato il puntatore nullo. Di conseguenza, il programmatore può sapere se il cast è andato a buon fine controllando se il puntatore è non nullo:</p>
<pre><code class="language-cpp">  <span class="hljs-keyword">if</span> (d1_ptr != <span class="hljs-literal">nullptr</span>) {
	<span class="hljs-comment">/* d1_ptr è valido */</span>
  }

  <span class="hljs-keyword">if</span> (d1_ptr) {
    <span class="hljs-comment">/* equivalente: ho sfruttato la conversione a bool */</span>
  }

  <span class="hljs-keyword">if</span> (D1* d1_ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;D1*&gt;(b_ptr)) {
    <span class="hljs-comment">/* equivalente: ho compattato cast e test */</span>
  }
</code></pre>
<p>Il caso di conversione per un riferimento è diverso (e raro), perché non esiste il concetto di riferimento nullo e quindi NON possiamo usare facilmente cast dinamici su riferimento per fare dei test RTTI.
Se proviamo ad eseguire questo:</p>
<pre><code class="language-cpp">  D1&amp; d1_ref = <span class="hljs-keyword">dynamic_cast</span>&lt;D1&amp;&gt;(*b_ptr)
</code></pre>
<p>se <code>b_ptr</code> punta ad un <code>D1</code>, il cast va a buon fine e <code>d1_ref</code> è inizializzato correttamente; se invece NON punta a <code>D1</code>, il cast dinamico fallisce e, non potendo segnalare la cosa con il riferiemento nullo, genera una eccezione (di tipo <code>std::bad_cast</code>).</p>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="constcast" tabindex="-1"><a class="anchor" href="#constcast" aria-hidden="true"><span class="octicon octicon-link"></span></a> const_cast</h3>
<p>Il const_cast viene usato per rimuovere la qualificazione const.
Tipicamente, si applica ad un riferimento o puntatore ad un oggetto qualificato <code>const</code> (cioè non modificabile) per ottenere un riferimento o puntatore ad un oggetto non qualificato (e quindi modificabile).</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">promessa_da_marinaio</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; ci)</span> </span>{
	<span class="hljs-keyword">int</span>&amp; i = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&gt;(ci);
	++i;
}
</code></pre>
<p>La funzione ha promesso al chiamante che NON modificherà l'argomento, ma si rimangia la promessa, elimina la qualificazione <code>const</code> e poi modifica l'argomento (proprio quello passato dal chiamante, non una copia).</p>
<p>Usando il <code>const_cast</code>, quindi, potremmo "rompere" il contratto stipulato con l'utente. Tra i pochi casi in cui può essere legittimo usare questo tipo di cast possiamo elencare i metodi di una classe che devono modificare la rappresentazione interna di un oggetto, senza però alterarne davvero il significato. Si tratta quindi di metodi che mantengono la "constness" a livello logico, pur violandola a livello fisico.</p>
<p>Esempio:
Una classe mantiene un collezione di elementi ed è fornita di un metodo (etichettato const) che stampa gli elementi secondo un dato ordinamento.
L'ordinamento è costoso da calcolare e quindi la collezione è mantenuta internamente NON ordinata. Quando però mi viene richiesta una stampa ordinata, potrei decidere di modificare la rappresentazione interna allo scopo di memorizzare la sequenza ordinata (di modo che successive chiamate della routine di stampa siano più efficienti). In questo caso, la routine di stampa potrebbe usare un <code>const_cast</code> per modificare la rappresentazione interna (senza però modificare dal punto di vista semantico la collezione).</p>
<blockquote>
<p>Nota: alcuni usi di <code>const_cast</code> si potrebbero eliminare mediante l'utilizzo del modificatore mutable su alcuni dati membro di una classe.</p>
</blockquote>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="reinterpretcast" tabindex="-1"><a class="anchor" href="#reinterpretcast" aria-hidden="true"><span class="octicon octicon-link"></span></a> reinterpret_cast</h3>
<p>Un reinterpret cast può essere usato per effettuare le seguenti conversioni:</p>
<ul>
<li>da un tipo puntatore ad un tipo intero (sufficientemente grande da poter rappresentare il valore del puntatore);</li>
<li>da un tipo intero/enumerazione ad un tipo puntatore;</li>
<li>da un tipo puntatore (oppure riferimento) ad un altro tipo puntatore (oppure riferimento).</li>
</ul>
<blockquote>
<p>Non è possibile usare un <code>reinterpret_cast</code> per rimuovere la qualificazione <code>const</code> (occorre usare il <code>const_cast</code>).</p>
</blockquote>
<blockquote>
<p>Nel caso del <code>reinterpret_cast</code> (diversamente dallo <code>static_cast</code>) le conversioni tra puntatori sono consentite anche quando i due tipi puntati NON sono in alcuna relazione tra di loro (in particolare, anche quando non fanno parte di una gerarchia di classi derivate). Quindi i <code>reinterpret_cast</code> sono una tra le forme di conversione più pericolose, in quanto i controlli di correttezza sono lasciati quasi completamente nelle mani del programmatore.</p>
</blockquote>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="cast-funzionale" tabindex="-1"><a class="anchor" href="#cast-funzionale" aria-hidden="true"><span class="octicon octicon-link"></span></a> cast funzionale</h3>
<p>La sintassi <code>T(expr)</code> oppure <code>T()</code>, dove <code>T</code> è il nome di un tipo, viene spesso indicata come "cast funzionale". Intuitivamente, corrisponde alla costruzione diretta di un oggetto di tipo <code>T</code>, usando un costruttore (nel secondo caso, il costruttore di default).
Si parla di cast funzionale in quanto la sintassi si può applicare anche al caso dei tipi built-in (che in senso tecnico non sono dotati di costruttori). Nel caso di un tipo built-in, la forma <code>T()</code> produce la cosiddetta zero-initialization.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t, U u)</span> </span>{
	<span class="hljs-keyword">if</span> (t == <span class="hljs-built_in">T</span>(u)) <span class="hljs-comment">// cast funzionale</span>
		<span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Se foo viene istanziata con <code>T = int</code> e <code>U = double</code>, il test condizionale diventa</p>
<pre><code class="language-cpp"><span class="hljs-keyword">if</span> (t == <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(u))
</code></pre>
<p>nel quale abbiamo il cast funzionale <code>int(u)</code>.</p>
<p><a href="#cast"><em>Torna all'indice</em></a></p>
<hr>
<h3 id="cast-stile-c" tabindex="-1"><a class="anchor" href="#cast-stile-c" aria-hidden="true"><span class="octicon octicon-link"></span></a> cast stile C</h3>
<p>Hanno la sintassi</p>
<pre><code class="language-cpp">(T) expr
</code></pre>
<p>Il loro uso è considerato cattivo stile (tranne il caso nominato sopra del cast a void per sopprimere warning del compilatore), perché:</p>
<ul>
<li>sono difficili da individuare nel codice mediante ricerca testuale;</li>
<li>non differenziano le diverse tipologie di cast.</li>
</ul>
<p>Con i cast stile C si possono simulare <code>static_cast</code>, <code>const_cast</code> e <code>reinterpret_cast</code>, ma NON si possono effettuare i <code>dynamic_cast</code> (in particolare, non hanno accesso a informazioni <em>RTTI</em> e quindi non effettuano nessun controllo a run-time).</p>
<p><a href="#cast"><em>Torna all'indice</em></a></p>

		</main>
	</body>
</html>
