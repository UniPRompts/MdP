<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
		<title>16-smart_pointers</title>
		<style>
			/* PDF Specific */

@media print {
  body {
    min-width: initial;
    max-width: 100%;
    margin: 0 auto;
  }
}

/* General */

.octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.anchor:focus {
  outline: none;
}

h1 .octicon-link,
h2 .octicon-link,
h3 .octicon-link,
h4 .octicon-link,
h5 .octicon-link,
h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
  text-decoration: none;
}

h1:hover .anchor .octicon-link,
h2:hover .anchor .octicon-link,
h3:hover .anchor .octicon-link,
h4:hover .anchor .octicon-link,
h5:hover .anchor .octicon-link,
h6:hover .anchor .octicon-link {
  visibility: visible;
}

h1:hover .anchor .octicon-link:before,
h2:hover .anchor .octicon-link:before,
h3:hover .anchor .octicon-link:before,
h4:hover .anchor .octicon-link:before,
h5:hover .anchor .octicon-link:before,
h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' width='16' height='16' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z'%3E%3C/path%3E%3C/svg%3E");
}

body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  -webkit-print-color-adjust: exact;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial,
    sans-serif, Apple Color Emoji, Segoe UI Emoji;
  font-size: 16px;
  line-height: 1.5;
  color: #24292e;
  word-wrap: break-word;
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 1rem auto;
}

details {
  display: block;
}

summary {
  display: list-item;
}

a {
  background-color: initial;
}

a:active,
a:hover {
  outline-width: 0;
}

strong {
  font-weight: inherit;
  font-weight: bolder;
}

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

img {
  border-style: none;
}

code,
kbd,
pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

hr {
  box-sizing: initial;
  height: 0;
  overflow: visible;
}

input {
  font: inherit;
  margin: 0;
}

input {
  overflow: visible;
}

[type='checkbox'] {
  box-sizing: border-box;
  padding: 0;
}

* {
  box-sizing: border-box;
}

input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

strong {
  font-weight: 600;
}

hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}

hr:after,
hr:before {
  display: table;
  content: '';
}

hr:after {
  clear: both;
}

table {
  border-spacing: 0;
  border-collapse: collapse;
}

td,
th {
  padding: 0;
}

details summary {
  cursor: pointer;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 0;
  margin-bottom: 0;
}

h1 {
  font-size: 32px;
}

h1,
h2 {
  font-weight: 600;
}

h2 {
  font-size: 24px;
}

h3 {
  font-size: 20px;
}

h3,
h4 {
  font-weight: 600;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h5,
h6 {
  font-weight: 600;
}

h6 {
  font-size: 12px;
}

p {
  margin-top: 0;
  margin-bottom: 10px;
}

blockquote {
  margin: 0;
}

ol,
ul {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

ol ol,
ul ol {
  list-style-type: lower-roman;
}

ol ol ol,
ol ul ol,
ul ol ol,
ul ul ol {
  list-style-type: lower-alpha;
}

dd {
  margin-left: 0;
}

code,
pre {
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
}

pre {
  margin-top: 0;
  margin-bottom: 0;
}

input::-webkit-inner-spin-button,
input::-webkit-outer-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

:checked + .radio-label {
  position: relative;
  z-index: 1;
  border-color: #0366d6;
}

.border {
  border: 1px solid #e1e4e8 !important;
}

.border-0 {
  border: 0 !important;
}

.border-bottom {
  border-bottom: 1px solid #e1e4e8 !important;
}

.rounded-1 {
  border-radius: 3px !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-gray-light {
  background-color: #fafbfc !important;
}

.text-gray-light {
  color: #6a737d !important;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-top: 8px !important;
  margin-bottom: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3,
.px-3 {
  padding-left: 16px !important;
}

.px-3 {
  padding-right: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.f6 {
  font-size: 12px !important;
}

.lh-condensed {
  line-height: 1.25 !important;
}

.text-bold {
  font-weight: 600 !important;
}

.pl-c {
  color: #6a737d;
}

.pl-c1,
.pl-s .pl-v {
  color: #005cc5;
}

.pl-e,
.pl-en {
  color: #6f42c1;
}

.pl-s .pl-s1,
.pl-smi {
  color: #24292e;
}

.pl-ent {
  color: #22863a;
}

.pl-k {
  color: #d73a49;
}

.pl-pds,
.pl-s,
.pl-s .pl-pse .pl-s1,
.pl-sr,
.pl-sr .pl-cce,
.pl-sr .pl-sra,
.pl-sr .pl-sre {
  color: #032f62;
}

.pl-smw,
.pl-v {
  color: #e36209;
}

.pl-bu {
  color: #b31d28;
}

.pl-ii {
  color: #fafbfc;
  background-color: #b31d28;
}

.pl-c2 {
  color: #fafbfc;
  background-color: #d73a49;
}

.pl-c2:before {
  content: '^M';
}

.pl-sr .pl-cce {
  font-weight: 700;
  color: #22863a;
}

.pl-ml {
  color: #735c0f;
}

.pl-mh,
.pl-mh .pl-en,
.pl-ms {
  font-weight: 700;
  color: #005cc5;
}

.pl-mi {
  font-style: italic;
  color: #24292e;
}

.pl-mb {
  font-weight: 700;
  color: #24292e;
}

.pl-md {
  color: #b31d28;
  background-color: #ffeef0;
}

.pl-mi1 {
  color: #22863a;
  background-color: #f0fff4;
}

.pl-mc {
  color: #e36209;
  background-color: #ffebda;
}

.pl-mi2 {
  color: #f6f8fa;
  background-color: #005cc5;
}

.pl-mdr {
  font-weight: 700;
  color: #6f42c1;
}

.pl-ba {
  color: #586069;
}

.pl-sg {
  color: #959da5;
}

.pl-corl {
  text-decoration: underline;
  color: #032f62;
}

.mb-0 {
  margin-bottom: 0 !important;
}

.my-2 {
  margin-bottom: 8px !important;
}

.my-2 {
  margin-top: 8px !important;
}

.pl-0 {
  padding-left: 0 !important;
}

.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

.pl-1 {
  padding-left: 4px !important;
}

.pl-2 {
  padding-left: 8px !important;
}

.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}

.pl-3 {
  padding-left: 16px !important;
}

.pl-4 {
  padding-left: 24px !important;
}

.pl-5 {
  padding-left: 32px !important;
}

.pl-6 {
  padding-left: 40px !important;
}

.pl-7 {
  padding-left: 48px !important;
}

.pl-8 {
  padding-left: 64px !important;
}

.pl-9 {
  padding-left: 80px !important;
}

.pl-10 {
  padding-left: 96px !important;
}

.pl-11 {
  padding-left: 112px !important;
}

.pl-12 {
  padding-left: 128px !important;
}

hr {
  border-bottom-color: #eee;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #d1d5da;
}

body:after,
body:before {
  display: table;
  content: '';
}

body:after {
  clear: both;
}

body > :first-child {
  margin-top: 0 !important;
}

body > :last-child {
  margin-bottom: 0 !important;
}

a:not([href]) {
  color: inherit;
  text-decoration: none;
}

blockquote,
details,
dl,
ol,
p,
pre,
table,
ul {
  margin-top: 0;
  margin-bottom: 16px;
}

hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}

blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
}

blockquote > :first-child {
  margin-top: 0;
}

blockquote > :last-child {
  margin-bottom: 0;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h1 {
  font-size: 2em;
}

h1,
h2 {
  padding-bottom: 0.3em;
  border-bottom: 1px solid #eaecef;
}

h2 {
  font-size: 1.5em;
}

h3 {
  font-size: 1.25em;
}

h4 {
  font-size: 1em;
}

h5 {
  font-size: 0.875em;
}

h6 {
  font-size: 0.85em;
  color: #6a737d;
}

ol,
ul {
  padding-left: 2em;
}

ol ol,
ol ul,
ul ol,
ul ul {
  margin-top: 0;
  margin-bottom: 0;
}

li {
  word-wrap: break-all;
}

li > p {
  margin-top: 16px;
}

li + li {
  margin-top: 0.25em;
}

dl {
  padding: 0;
}

dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

table {
  display: block;
  width: 100%;
  overflow: auto;
}

table th {
  font-weight: 600;
}

table td,
table th {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

img {
  max-width: 80%;
  box-sizing: initial;
  display: block;
  margin-left: auto;
  margin-right: auto;
  background-color: #fff;
}

code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27, 31, 35, 0.05);
  border-radius: 3px;
}

pre {
  word-wrap: normal;
}

pre > code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  -webkit-print-color-adjust: exact;
  background: #f8f8f8;
}

.hljs pre {
  margin-bottom: 0;
  word-break: normal;
}

.hljs pre,
pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  -webkit-print-color-adjust: exact;

  border-radius: 3px;
}

pre code {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: initial;
  border: 0;
}

.commit-tease-sha {
  display: inline-block;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 90%;
  color: #444d56;
}

.full-commit .btn-outline:not(:disabled):hover {
  color: #005cc5;
  border-color: #005cc5;
}

.blob-wrapper {
  overflow-x: auto;
  overflow-y: hidden;
}

.blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.blob-num {
  width: 1%;
  min-width: 50px;
  padding-right: 10px;
  padding-left: 10px;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  line-height: 20px;
  color: rgba(27, 31, 35, 0.3);
  text-align: right;
  white-space: nowrap;
  vertical-align: top;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.blob-num:hover {
  color: rgba(27, 31, 35, 0.6);
}

.blob-num:before {
  content: attr(data-line-number);
}

.blob-code {
  position: relative;
  padding-right: 10px;
  padding-left: 10px;
  line-height: 20px;
  vertical-align: top;
}

.blob-code-inner {
  overflow: visible;
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  font-size: 12px;
  color: #24292e;
  word-wrap: normal;
  white-space: pre;
}

.pl-token.active,
.pl-token:hover {
  cursor: pointer;
  background: #ffea7f;
}

.tab-size[data-tab-size='1'] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.tab-size[data-tab-size='2'] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.tab-size[data-tab-size='3'] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.tab-size[data-tab-size='4'] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.tab-size[data-tab-size='5'] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.tab-size[data-tab-size='6'] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.tab-size[data-tab-size='7'] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.tab-size[data-tab-size='8'] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.tab-size[data-tab-size='9'] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.tab-size[data-tab-size='10'] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.tab-size[data-tab-size='11'] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.tab-size[data-tab-size='12'] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.task-list-item {
  list-style-type: none;
}

.task-list-item + .task-list-item {
  margin-top: 3px;
}

.task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}
/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/
  
  .hljs-comment,
  .hljs-quote {
    color: #998;
    font-style: italic;
  }
  
  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-subst {
    color: #333;
    font-weight: bold;
  }
  
  .hljs-number,
  .hljs-literal,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-tag .hljs-attr {
    color: #008080;
  }
  
  .hljs-string,
  .hljs-doctag {
    color: #d14;
  }
  
  .hljs-title,
  .hljs-section,
  .hljs-selector-id {
    color: #900;
    font-weight: bold;
  }
  
  .hljs-subst {
    font-weight: normal;
  }
  
  .hljs-type,
  .hljs-class .hljs-title {
    color: #458;
    font-weight: bold;
  }
  
  .hljs-tag,
  .hljs-name,
  .hljs-attribute {
    color: #000080;
    font-weight: normal;
  }
  
  .hljs-regexp,
  .hljs-link {
    color: #009926;
  }
  
  .hljs-symbol,
  .hljs-bullet {
    color: #990073;
  }
  
  .hljs-built_in,
  .hljs-builtin-name {
    color: #0086b3;
  }
  
  .hljs-meta {
    color: #999;
    font-weight: bold;
  }
  
  .hljs-deletion {
    background: #fdd;
  }
  
  .hljs-addition {
    background: #dfd;
  }
  
  .hljs-emphasis {
    font-style: italic;
  }
  
  .hljs-strong {
    font-weight: bold;
  }
		</style>
<script> MathJax = { tex: { inlineMath: [["$", "$"]] } }; </script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
	</head>
	<body>
		<nav id="table-of-contents">
			<ul><li><a href="#smart-pointers"> Smart pointers</a><ul><li><a href="#uniqueptr"> unique_ptr</a></li><li><a href="#sharedptr"> shared_ptr</a></li><li><a href="#template-di-funzione-makeshared-e-makeunique"> Template di funzione (make_shared e make_unique)</a></li><li><a href="#weakptr"> weak_ptr</a></li></ul></li></ul>
		</nav>
		<main>
			<h1 id="smart-pointers" tabindex="-1"><a class="anchor" href="#smart-pointers" aria-hidden="true"><span class="octicon octicon-link"></span></a> Smart pointers</h1>
<pre><code class="language-toc"></code></pre>
<hr>
<p>Come accennato quando si è introdotto il discorso della gestione delle risorse e dell'exception safety, uno dei casi più frequenti che si verificano è quello della corretta gestione dell'allocazione dinamica della memoria.</p>
<p>L'uso dei semplici puntatori forniti dal linguaggio (detti anche puntatori "raw" o "naked" o addirittura "dumb", in contrapposizione a quelli "smart", ovvero intelligenti) si presta infatti a tutta una serie di possibili errori di programmazione nei quali può incappare anche un programmatore esperto (se cala il livello di attenzione).</p>
<p>L'idioma RAII-RRID si presta bene a neutralizzare la maggior parte di questi errori, rendendoli molto meno probabili.
D'altra parte, scrivere una classe RAII per ogni tipo <code>T</code> ogni volta che si vuole usare un <code>T*</code> è operazione noiosa, ripetitiva e comunque soggetta a errori.</p>
<p><mark style="background: #BBFABBA6;">La libreria standard viene però in aiuto, fornendo delle classi templatiche che forniscono diverse tipologie di puntatori "smart":</mark> <code>unique_ptr</code>, <code>shared_ptr</code> e <code>weak_ptr</code>.
Le tre classi templatiche sono definite nell'header file <code>&lt;memory&gt;</code>.</p>
<blockquote>
<p><mark style="background: #FF5582A6;">NOTA BENE:</mark> i puntatori smart forniti dalla libreria standard sono concepiti per memorizzare puntatori a memoria allocata dinamicamente sotto il controllo del programmatore; non si possono utilizzare per la memoria ad allocazione statica o per la memoria ad allocazione automatica (sullo stack di sistema).</p>
</blockquote>
<p><a href="#smart%20pointers"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="uniqueptr" tabindex="-1"><a class="anchor" href="#uniqueptr" aria-hidden="true"><span class="octicon octicon-link"></span></a> unique_ptr</h2>
<p>Uno <code>std::unique_ptr&lt;T&gt;</code> è un <mark style="background: #ABF7F7A6;">puntatore smart</mark> ad un oggetto di tipo <code>T</code>.
In particolare, <code>unique_ptr</code> implementa il concetto di puntatore "<em>owning</em>", ovvero un puntatore che si considera l'unico proprietario della risorsa.</p>
<p>Intuitivamente, allo smart pointer spetta l'onere di fornire una corretta gestione della risorsa (nello specifico, rilasciarla a lavoro finito).</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-function">std::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;
	<span class="hljs-function">std::unique_ptr&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>(<span class="hljs-number">3.1415</span>))</span></span>;
	*pd *= *pd; <span class="hljs-comment">// si dereferenzia come un puntatore</span>
	<span class="hljs-comment">// altri usi ...</span>
} <span class="hljs-comment">// qui termina il tempo di vita di pi e pd e viene rilasciata la memoria</span>
</code></pre>
<p><mark style="background: #FFB86CA6;">Una caratteristica degli unique_ptr è il fatto di NON essere copiabili, ma di essere (solo) spostabili.</mark> La copia è impedita in quanto violerebbe il requisito di unicità del gestore della risorsa; lo spostamento è invece consentito, in quanto si trasferisce la proprietà della risorsa al nuovo gestore.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; pi)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;
  <span class="hljs-comment">// foo(pj);         // errore di compilazione: copia non ammessa</span>
  <span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">move</span>(pj)); <span class="hljs-comment">// ok: spostamento ammesso</span>
  <span class="hljs-comment">// dopo lo spostamento, pj non gestisce nessuna risorsa</span>
}
</code></pre>
<p>La classe fornisce poi metodi per potere interagire con i puntatori "raw", da usarsi nel caso in cui ci si debba interfacciare con codice che, per esempio, era stato sviluppato prima dell'adozione dello standard $C$++11.</p>
<p>Esempio:</p>
<pre><code class="language-cpp">std::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; pi;    <span class="hljs-comment">// pi non gestisce (ancora) una risorsa</span>
<span class="hljs-keyword">int</span>* raw_pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">42</span>);

pi.<span class="hljs-built_in">reset</span>(raw_pi);           <span class="hljs-comment">// NON devo invocare la delete su raw_pi</span>

<span class="hljs-keyword">int</span>* raw_pj = pi.<span class="hljs-built_in">get</span>();     <span class="hljs-comment">// NON devo invocare la delete su raw_pj</span>
<span class="hljs-keyword">int</span>* raw_pk = pi.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// devo invocare la delete su raw_pk</span>
</code></pre>
<p>Con il metodo <code>reset()</code> il puntatore prende in gestione una nuova risorsa (diventandone il proprietario), rilasciando la risorsa che aveva in gestione precedentemente, se presente.</p>
<p>Il metodo <code>get()</code> fornisce il puntatore raw alla risorsa gestita, che però rimane sotto la responsabilità dello <code>unique_ptr</code>; il metodo <code>release()</code>, invece, restituisce il puntatore raw e ne cede anche la responsabilità di corretta gestione.</p>
<p><a href="#smart%20pointers"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="sharedptr" tabindex="-1"><a class="anchor" href="#sharedptr" aria-hidden="true"><span class="octicon octicon-link"></span></a> shared_ptr</h2>
<p>Uno <code>std::shared_ptr&lt;T&gt;</code> è un <mark style="background: #ABF7F7A6;">puntatore smart</mark> ad un oggetto di tipo <code>T</code>.
Lo <code>shared_ptr</code> <mark style="background: #FFB86CA6;">implementa il concetto di puntatore per il quale la responsabilità della corretta gestione della risorsa è "condivisa"</mark>: intuitivamente, ogni volta che uno <code>shared_ptr</code> viene <em>copiato</em>, l'originale e la copia condividono la responsabilità della gestione della (stessa) risorsa.</p>
<p>A livello di implementazione, la copia causa l'incrementato di un contatore del numero di riferimenti alla risorsa (<code>reference counter</code>).</p>
<p>Quando uno <code>shared_ptr</code> viene distrutto, decrementa il <code>reference counter</code> associato alla risorsa e, se si accorge di essere rimasto l'unico <code>shared_ptr</code> ad avervi ancora accesso, ne effettua il rilascio (informalmente, si dice che "<em>l'ultimo chiude la porta</em>").</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
	std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; pi;
	
	{
		<span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>; <span class="hljs-comment">// ref counter = 1</span>
		pi = pj;  <span class="hljs-comment">// condivisione risorsa, ref counter = 2</span>
		++(*pi);  <span class="hljs-comment">// uso risorsa condivisa: nuovo valore 43</span>
		++(*pj);  <span class="hljs-comment">// uso risorsa condivisa: nuovo valore 44</span>
	} <span class="hljs-comment">// distruzione pj, ref counter = 1</span>
	
	++(*pi);    <span class="hljs-comment">// uso risorsa condivisa: nuovo valore 45</span>
	
} <span class="hljs-comment">// distruzione pj, ref counter = 0, rilascio risorsa</span>
</code></pre>
<p>Come detto, gli <code>shared_ptr</code> sono <em>copiabili</em> (e spostabili).
La classe fornisce i metodi <code>reset()</code> e <code>get()</code>, con la semantica intuitiva.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; pi)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;
	
	<span class="hljs-built_in">foo</span>(pj);            <span class="hljs-comment">// ok: copia ammessa, risorsa condivisa</span>
	std::cout &lt;&lt; *pj;   <span class="hljs-comment">// stampa la risorsa come modificata da foo</span>
	
	<span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">move</span>(pj)); <span class="hljs-comment">// ok: spostamento ammesso</span>
	<span class="hljs-comment">// dopo lo spostamento, pj non gestisce nessuna risorsa</span>
}
</code></pre>
<p><a href="#smart%20pointers"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="template-di-funzione-makeshared-e-makeunique" tabindex="-1"><a class="anchor" href="#template-di-funzione-makeshared-e-makeunique" aria-hidden="true"><span class="octicon octicon-link"></span></a> Template di funzione (make_shared e make_unique)</h2>
<p>Un puntatore shared deve interagire con due componenti: la risorsa e il "blocco di controllo" della risorsa (una porzione di memoria nella quale viene salvato anche il reference counter).
Per motivi di efficienza, sarebbe bene che queste due componenti fossero allocate con una singola operazione: questa è la garanzia offerta dalla <code>std::make_shared</code>.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-keyword">auto</span> pi = std::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);
	<span class="hljs-keyword">auto</span> pj = std::make_shared&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">3.1415</span>);
}
</code></pre>
<p>Oltre all'efficienza, l'uso di <code>std::make_shared</code> consente di evitare alcuni errori subdoli che potrebbero compromettere la corretta gestione delle risorse in presenza di comportamenti eccezionali.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; pi,
         std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; pj)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// codice NON exception safe</span>
  <span class="hljs-built_in">bar</span>(std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">42</span>)),
      std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">42</span>)));

  <span class="hljs-comment">// codice exception safe</span>
  <span class="hljs-built_in">bar</span>(std::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>),
      std::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>));
}
</code></pre>
<p>Siccome l'ordine di esecuzione delle sottoespressioni è non specificato, nella prima chiamata della funzione <code>bar()</code> una implementazione potrebbe decidere di valutare per prime le due espressioni <code>new</code> passate come argomenti ai costruttori degli <code>shared_ptr</code> e solo dopo invocare i costruttori.</p>
<p>Se la prima allocazione tramite <code>new</code> andasse a buon fine ma la seconda invece fallisse con una eccezione, si otterrebbe un memory leak (per la prima risorsa allocata), in quanto il distruttore dello <code>shared_ptr</code> NON verrebbe invocato (perché l'oggetto non è stato costruito).</p>
<p>Il problema non si presenta nella seconda chiamata a <code>bar()</code>, perché le allocazioni sono effettuate (implicitamente) dalla <code>make_shared</code>.</p>
<blockquote>
<p><mark style="background: #FF5582A6;">NOTA:</mark> questo esempio NON dovrebbe causare un problema di exception safety nel caso di una implementazione conforme allo standard $C$++17: in questo standard, infatti, è stata modificata la regola relativa all'ordine di valutazione degli argomenti in una chiamata di funzione.</p>
</blockquote>
<p>A partire dallo standard $C$++14 è stata resa disponibile anche la <code>std::make_unique</code>. L'uso degli smart pointer e di queste funzioni per la loro creazione dovrebbe consentire al programmatore di limitare al massimo la necessità di utilizzare (esplicitamente) le espressioni <code>new</code> e le corrispondenti invocazioni di <code>delete</code>: in effetti, nelle più recenti linee guida alla programmazione in $C$++, l'uso diretto (naked) di <code>new</code> e <code>delete</code> è considerato "cattivo stile", quasi quanto l'uso dell'istruzione <code>goto</code>.</p>
<p>http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines</p>
<p><a href="#smart%20pointers"><em>Torna all'indice</em></a></p>
<hr>
<h2 id="weakptr" tabindex="-1"><a class="anchor" href="#weakptr" aria-hidden="true"><span class="octicon octicon-link"></span></a> weak_ptr</h2>
<p>Un problema che si potrebbe presentare quando si usano gli <code>shared_ptr</code> (più in generale, quando si usa qualunque meccanismo di condivisione di risorse basato sui reference counter) è dato dalla possibilità di creare insiemi di risorse che, puntandosi reciprocamente tramite <code>shared_ptr</code>, formano una o più strutture cicliche.</p>
<p>In questo caso, le risorse comprese in un ciclo mantengono dei reference count positivi anche se non sono più raggiungibili a partire dagli shared_ptr ancora accessibili da parte del programma, causando dei memory leak. L'uso dei <code>std::weak_ptr</code> è pensato per risolvere questi problemi.</p>
<p>Un <code>weak_ptr</code> è un <mark style="background: #BBFABBA6;">puntatore ad una risorsa condivisa che però non partecipa attivamente alla gestione della risorsa stessa</mark>: la risorsa viene quindi rilasciata quando si distrugge l'ultimo <code>shared_ptr</code>, anche se esistono dei <code>weak_ptr</code> che la indirizzano. Ciò significa che un <code>weak_ptr</code> non può accedere direttamente alla risorsa: prima di farlo, deve controllare se la risorsa è ancora disponibile. Il modo migliore per farlo è mediante l'invocazione del metodo <code>lock()</code>, che produce uno <code>shared_ptr</code> a partire dal <code>weak_ptr</code>: se la risorsa non è più disponibile, lo <code>shared_ptr</code> ottenuto conterrà il puntatore nullo.</p>
<p>Esempio:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maybe_print</span><span class="hljs-params">(std::weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; wp)</span> </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sp2 = wp.<span class="hljs-built_in">lock</span>())
		std::cout &lt;&lt; *sp2;
	<span class="hljs-keyword">else</span>
		std::cout &lt;&lt; <span class="hljs-string">"non più disponibile"</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
	std::weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; wp;
	{
		<span class="hljs-keyword">auto</span> sp = std::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);
		wp = sp; <span class="hljs-comment">// wp non incrementa il reference count della risorsa</span>
		*sp = <span class="hljs-number">55</span>;
		<span class="hljs-built_in">maybe_print</span>(wp); <span class="hljs-comment">// stampa 55</span>
	} <span class="hljs-comment">// sp viene distrutto, insieme alla risorsa</span>
	
	<span class="hljs-built_in">maybe_print</span>(wp); <span class="hljs-comment">// stampa "non più disponibile"</span>
}
</code></pre>
<p><a href="#smart%20pointers"><em>Torna all'indice</em></a></p>

		</main>
	</body>
</html>
